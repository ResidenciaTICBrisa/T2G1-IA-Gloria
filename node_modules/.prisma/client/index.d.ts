
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Occurrence
 * 
 */
export type Occurrence = $Result.DefaultSelection<Prisma.$OccurrencePayload>
/**
 * Model TypesOfViolence
 * 
 */
export type TypesOfViolence = $Result.DefaultSelection<Prisma.$TypesOfViolencePayload>
/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserIP
 * 
 */
export type UserIP = $Result.DefaultSelection<Prisma.$UserIPPayload>
/**
 * Model UserOccurrences
 * 
 */
export type UserOccurrences = $Result.DefaultSelection<Prisma.$UserOccurrencesPayload>
/**
 * Model ViolenceSituations
 * 
 */
export type ViolenceSituations = $Result.DefaultSelection<Prisma.$ViolenceSituationsPayload>
/**
 * Model StateList
 * 
 */
export type StateList = $Result.DefaultSelection<Prisma.$StateListPayload>
/**
 * Model Access
 * 
 */
export type Access = $Result.DefaultSelection<Prisma.$AccessPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Occurrences
 * const occurrences = await prisma.occurrence.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  T extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof T ? T['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<T['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Occurrences
   * const occurrences = await prisma.occurrence.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<T, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<'extends', Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.occurrence`: Exposes CRUD operations for the **Occurrence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Occurrences
    * const occurrences = await prisma.occurrence.findMany()
    * ```
    */
  get occurrence(): Prisma.OccurrenceDelegate<ExtArgs>;

  /**
   * `prisma.typesOfViolence`: Exposes CRUD operations for the **TypesOfViolence** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TypesOfViolences
    * const typesOfViolences = await prisma.typesOfViolence.findMany()
    * ```
    */
  get typesOfViolence(): Prisma.TypesOfViolenceDelegate<ExtArgs>;

  /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.userIP`: Exposes CRUD operations for the **UserIP** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserIPS
    * const userIPS = await prisma.userIP.findMany()
    * ```
    */
  get userIP(): Prisma.UserIPDelegate<ExtArgs>;

  /**
   * `prisma.userOccurrences`: Exposes CRUD operations for the **UserOccurrences** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserOccurrences
    * const userOccurrences = await prisma.userOccurrences.findMany()
    * ```
    */
  get userOccurrences(): Prisma.UserOccurrencesDelegate<ExtArgs>;

  /**
   * `prisma.violenceSituations`: Exposes CRUD operations for the **ViolenceSituations** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ViolenceSituations
    * const violenceSituations = await prisma.violenceSituations.findMany()
    * ```
    */
  get violenceSituations(): Prisma.ViolenceSituationsDelegate<ExtArgs>;

  /**
   * `prisma.stateList`: Exposes CRUD operations for the **StateList** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StateLists
    * const stateLists = await prisma.stateList.findMany()
    * ```
    */
  get stateList(): Prisma.StateListDelegate<ExtArgs>;

  /**
   * `prisma.access`: Exposes CRUD operations for the **Access** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accesses
    * const accesses = await prisma.access.findMany()
    * ```
    */
  get access(): Prisma.AccessDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql

  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.14.0
   * Query Engine version: 473ed3124229e22d881cb7addf559799debae1ab
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON object.
   * This type can be useful to enforce some input to be JSON-compatible or as a super-type to be extended from. 
   */
  export type JsonObject = {[Key in string]?: JsonValue}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches a JSON array.
   */
  export interface JsonArray extends Array<JsonValue> {}

  /**
   * From https://github.com/sindresorhus/type-fest/
   * Matches any valid JSON value.
   */
  export type JsonValue = string | number | boolean | JsonObject | JsonArray | null

  /**
   * Matches a JSON object.
   * Unlike `JsonObject`, this type allows undefined and read-only properties.
   */
  export type InputJsonObject = {readonly [Key in string]?: InputJsonValue | null}

  /**
   * Matches a JSON array.
   * Unlike `JsonArray`, readonly arrays are assignable to this type.
   */
  export interface InputJsonArray extends ReadonlyArray<InputJsonValue | null> {}

  /**
   * Matches any valid value that can be used as an input for operations like
   * create and update as the value of a JSON field. Unlike `JsonValue`, this
   * type allows read-only arrays and read-only object properties and disallows
   * `null` at the top level.
   *
   * `null` cannot be used as the value of a JSON field because its meaning
   * would be ambiguous. Use `Prisma.JsonNull` to store the JSON null value or
   * `Prisma.DbNull` to clear the JSON value and set the field to the database
   * NULL value instead.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-by-null-values
   */
  export type InputJsonValue = string | number | boolean | InputJsonObject | InputJsonArray | { toJSON(): unknown }

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Occurrence: 'Occurrence',
    TypesOfViolence: 'TypesOfViolence',
    User: 'User',
    UserIP: 'UserIP',
    UserOccurrences: 'UserOccurrences',
    ViolenceSituations: 'ViolenceSituations',
    StateList: 'StateList',
    Access: 'Access'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }


  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs}, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    meta: {
      modelProps: 'occurrence' | 'typesOfViolence' | 'user' | 'userIP' | 'userOccurrences' | 'violenceSituations' | 'stateList' | 'access'
      txIsolationLevel: Prisma.TransactionIsolationLevel
    },
    model: {
      Occurrence: {
        payload: Prisma.$OccurrencePayload<ExtArgs>
        fields: Prisma.OccurrenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.OccurrenceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OccurrencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.OccurrenceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OccurrencePayload>
          }
          findFirst: {
            args: Prisma.OccurrenceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OccurrencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.OccurrenceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OccurrencePayload>
          }
          findMany: {
            args: Prisma.OccurrenceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OccurrencePayload>[]
          }
          create: {
            args: Prisma.OccurrenceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OccurrencePayload>
          }
          createMany: {
            args: Prisma.OccurrenceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.OccurrenceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OccurrencePayload>
          }
          update: {
            args: Prisma.OccurrenceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OccurrencePayload>
          }
          deleteMany: {
            args: Prisma.OccurrenceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.OccurrenceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.OccurrenceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$OccurrencePayload>
          }
          aggregate: {
            args: Prisma.OccurrenceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateOccurrence>
          }
          groupBy: {
            args: Prisma.OccurrenceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<OccurrenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.OccurrenceCountArgs<ExtArgs>,
            result: $Utils.Optional<OccurrenceCountAggregateOutputType> | number
          }
        }
      }
      TypesOfViolence: {
        payload: Prisma.$TypesOfViolencePayload<ExtArgs>
        fields: Prisma.TypesOfViolenceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TypesOfViolenceFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypesOfViolencePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TypesOfViolenceFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypesOfViolencePayload>
          }
          findFirst: {
            args: Prisma.TypesOfViolenceFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypesOfViolencePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TypesOfViolenceFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypesOfViolencePayload>
          }
          findMany: {
            args: Prisma.TypesOfViolenceFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypesOfViolencePayload>[]
          }
          create: {
            args: Prisma.TypesOfViolenceCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypesOfViolencePayload>
          }
          createMany: {
            args: Prisma.TypesOfViolenceCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.TypesOfViolenceDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypesOfViolencePayload>
          }
          update: {
            args: Prisma.TypesOfViolenceUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypesOfViolencePayload>
          }
          deleteMany: {
            args: Prisma.TypesOfViolenceDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.TypesOfViolenceUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.TypesOfViolenceUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$TypesOfViolencePayload>
          }
          aggregate: {
            args: Prisma.TypesOfViolenceAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateTypesOfViolence>
          }
          groupBy: {
            args: Prisma.TypesOfViolenceGroupByArgs<ExtArgs>,
            result: $Utils.Optional<TypesOfViolenceGroupByOutputType>[]
          }
          count: {
            args: Prisma.TypesOfViolenceCountArgs<ExtArgs>,
            result: $Utils.Optional<TypesOfViolenceCountAggregateOutputType> | number
          }
        }
      }
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>,
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserIP: {
        payload: Prisma.$UserIPPayload<ExtArgs>
        fields: Prisma.UserIPFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserIPFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserIPPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserIPFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserIPPayload>
          }
          findFirst: {
            args: Prisma.UserIPFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserIPPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserIPFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserIPPayload>
          }
          findMany: {
            args: Prisma.UserIPFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserIPPayload>[]
          }
          create: {
            args: Prisma.UserIPCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserIPPayload>
          }
          createMany: {
            args: Prisma.UserIPCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserIPDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserIPPayload>
          }
          update: {
            args: Prisma.UserIPUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserIPPayload>
          }
          deleteMany: {
            args: Prisma.UserIPDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserIPUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserIPUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserIPPayload>
          }
          aggregate: {
            args: Prisma.UserIPAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserIP>
          }
          groupBy: {
            args: Prisma.UserIPGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserIPGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserIPCountArgs<ExtArgs>,
            result: $Utils.Optional<UserIPCountAggregateOutputType> | number
          }
        }
      }
      UserOccurrences: {
        payload: Prisma.$UserOccurrencesPayload<ExtArgs>
        fields: Prisma.UserOccurrencesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserOccurrencesFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOccurrencesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserOccurrencesFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOccurrencesPayload>
          }
          findFirst: {
            args: Prisma.UserOccurrencesFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOccurrencesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserOccurrencesFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOccurrencesPayload>
          }
          findMany: {
            args: Prisma.UserOccurrencesFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOccurrencesPayload>[]
          }
          create: {
            args: Prisma.UserOccurrencesCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOccurrencesPayload>
          }
          createMany: {
            args: Prisma.UserOccurrencesCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.UserOccurrencesDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOccurrencesPayload>
          }
          update: {
            args: Prisma.UserOccurrencesUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOccurrencesPayload>
          }
          deleteMany: {
            args: Prisma.UserOccurrencesDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.UserOccurrencesUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.UserOccurrencesUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$UserOccurrencesPayload>
          }
          aggregate: {
            args: Prisma.UserOccurrencesAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateUserOccurrences>
          }
          groupBy: {
            args: Prisma.UserOccurrencesGroupByArgs<ExtArgs>,
            result: $Utils.Optional<UserOccurrencesGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserOccurrencesCountArgs<ExtArgs>,
            result: $Utils.Optional<UserOccurrencesCountAggregateOutputType> | number
          }
        }
      }
      ViolenceSituations: {
        payload: Prisma.$ViolenceSituationsPayload<ExtArgs>
        fields: Prisma.ViolenceSituationsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ViolenceSituationsFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViolenceSituationsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ViolenceSituationsFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViolenceSituationsPayload>
          }
          findFirst: {
            args: Prisma.ViolenceSituationsFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViolenceSituationsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ViolenceSituationsFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViolenceSituationsPayload>
          }
          findMany: {
            args: Prisma.ViolenceSituationsFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViolenceSituationsPayload>[]
          }
          create: {
            args: Prisma.ViolenceSituationsCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViolenceSituationsPayload>
          }
          createMany: {
            args: Prisma.ViolenceSituationsCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.ViolenceSituationsDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViolenceSituationsPayload>
          }
          update: {
            args: Prisma.ViolenceSituationsUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViolenceSituationsPayload>
          }
          deleteMany: {
            args: Prisma.ViolenceSituationsDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.ViolenceSituationsUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.ViolenceSituationsUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$ViolenceSituationsPayload>
          }
          aggregate: {
            args: Prisma.ViolenceSituationsAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateViolenceSituations>
          }
          groupBy: {
            args: Prisma.ViolenceSituationsGroupByArgs<ExtArgs>,
            result: $Utils.Optional<ViolenceSituationsGroupByOutputType>[]
          }
          count: {
            args: Prisma.ViolenceSituationsCountArgs<ExtArgs>,
            result: $Utils.Optional<ViolenceSituationsCountAggregateOutputType> | number
          }
        }
      }
      StateList: {
        payload: Prisma.$StateListPayload<ExtArgs>
        fields: Prisma.StateListFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StateListFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StateListPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StateListFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StateListPayload>
          }
          findFirst: {
            args: Prisma.StateListFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StateListPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StateListFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StateListPayload>
          }
          findMany: {
            args: Prisma.StateListFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StateListPayload>[]
          }
          create: {
            args: Prisma.StateListCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StateListPayload>
          }
          createMany: {
            args: Prisma.StateListCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.StateListDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StateListPayload>
          }
          update: {
            args: Prisma.StateListUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StateListPayload>
          }
          deleteMany: {
            args: Prisma.StateListDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.StateListUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.StateListUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$StateListPayload>
          }
          aggregate: {
            args: Prisma.StateListAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateStateList>
          }
          groupBy: {
            args: Prisma.StateListGroupByArgs<ExtArgs>,
            result: $Utils.Optional<StateListGroupByOutputType>[]
          }
          count: {
            args: Prisma.StateListCountArgs<ExtArgs>,
            result: $Utils.Optional<StateListCountAggregateOutputType> | number
          }
        }
      }
      Access: {
        payload: Prisma.$AccessPayload<ExtArgs>
        fields: Prisma.AccessFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccessFindUniqueArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccessPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccessFindUniqueOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccessPayload>
          }
          findFirst: {
            args: Prisma.AccessFindFirstArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccessPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccessFindFirstOrThrowArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccessPayload>
          }
          findMany: {
            args: Prisma.AccessFindManyArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccessPayload>[]
          }
          create: {
            args: Prisma.AccessCreateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccessPayload>
          }
          createMany: {
            args: Prisma.AccessCreateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          delete: {
            args: Prisma.AccessDeleteArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccessPayload>
          }
          update: {
            args: Prisma.AccessUpdateArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccessPayload>
          }
          deleteMany: {
            args: Prisma.AccessDeleteManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          updateMany: {
            args: Prisma.AccessUpdateManyArgs<ExtArgs>,
            result: Prisma.BatchPayload
          }
          upsert: {
            args: Prisma.AccessUpsertArgs<ExtArgs>,
            result: $Utils.PayloadToResult<Prisma.$AccessPayload>
          }
          aggregate: {
            args: Prisma.AccessAggregateArgs<ExtArgs>,
            result: $Utils.Optional<AggregateAccess>
          }
          groupBy: {
            args: Prisma.AccessGroupByArgs<ExtArgs>,
            result: $Utils.Optional<AccessGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccessCountArgs<ExtArgs>,
            result: $Utils.Optional<AccessCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<'define', Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserIPCountOutputType
   */

  export type UserIPCountOutputType = {
    Occurrence: number
    UserOccurrences: number
  }

  export type UserIPCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Occurrence?: boolean | UserIPCountOutputTypeCountOccurrenceArgs
    UserOccurrences?: boolean | UserIPCountOutputTypeCountUserOccurrencesArgs
  }

  // Custom InputTypes
  /**
   * UserIPCountOutputType without action
   */
  export type UserIPCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIPCountOutputType
     */
    select?: UserIPCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserIPCountOutputType without action
   */
  export type UserIPCountOutputTypeCountOccurrenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OccurrenceWhereInput
  }

  /**
   * UserIPCountOutputType without action
   */
  export type UserIPCountOutputTypeCountUserOccurrencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserOccurrencesWhereInput
  }


  /**
   * Count Type StateListCountOutputType
   */

  export type StateListCountOutputType = {
    Occurrence: number
  }

  export type StateListCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Occurrence?: boolean | StateListCountOutputTypeCountOccurrenceArgs
  }

  // Custom InputTypes
  /**
   * StateListCountOutputType without action
   */
  export type StateListCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateListCountOutputType
     */
    select?: StateListCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StateListCountOutputType without action
   */
  export type StateListCountOutputTypeCountOccurrenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OccurrenceWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Occurrence
   */

  export type AggregateOccurrence = {
    _count: OccurrenceCountAggregateOutputType | null
    _avg: OccurrenceAvgAggregateOutputType | null
    _sum: OccurrenceSumAggregateOutputType | null
    _min: OccurrenceMinAggregateOutputType | null
    _max: OccurrenceMaxAggregateOutputType | null
  }

  export type OccurrenceAvgAggregateOutputType = {
    id_occurrence: number | null
    id_user: number | null
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type OccurrenceSumAggregateOutputType = {
    id_occurrence: bigint | null
    id_user: bigint | null
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type OccurrenceMinAggregateOutputType = {
    id_occurrence: bigint | null
    id_user: bigint | null
    datetime_submission: Date | null
    State_violence: string | null
    date_violence: Date | null
    time_violence: Date | null
    agegroup: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    violencesoptions: string | null
    violencetype: string | null
  }

  export type OccurrenceMaxAggregateOutputType = {
    id_occurrence: bigint | null
    id_user: bigint | null
    datetime_submission: Date | null
    State_violence: string | null
    date_violence: Date | null
    time_violence: Date | null
    agegroup: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    violencesoptions: string | null
    violencetype: string | null
  }

  export type OccurrenceCountAggregateOutputType = {
    id_occurrence: number
    id_user: number
    datetime_submission: number
    State_violence: number
    date_violence: number
    time_violence: number
    agegroup: number
    latitude: number
    longitude: number
    violencesoptions: number
    violencetype: number
    _all: number
  }


  export type OccurrenceAvgAggregateInputType = {
    id_occurrence?: true
    id_user?: true
    latitude?: true
    longitude?: true
  }

  export type OccurrenceSumAggregateInputType = {
    id_occurrence?: true
    id_user?: true
    latitude?: true
    longitude?: true
  }

  export type OccurrenceMinAggregateInputType = {
    id_occurrence?: true
    id_user?: true
    datetime_submission?: true
    State_violence?: true
    date_violence?: true
    time_violence?: true
    agegroup?: true
    latitude?: true
    longitude?: true
    violencesoptions?: true
    violencetype?: true
  }

  export type OccurrenceMaxAggregateInputType = {
    id_occurrence?: true
    id_user?: true
    datetime_submission?: true
    State_violence?: true
    date_violence?: true
    time_violence?: true
    agegroup?: true
    latitude?: true
    longitude?: true
    violencesoptions?: true
    violencetype?: true
  }

  export type OccurrenceCountAggregateInputType = {
    id_occurrence?: true
    id_user?: true
    datetime_submission?: true
    State_violence?: true
    date_violence?: true
    time_violence?: true
    agegroup?: true
    latitude?: true
    longitude?: true
    violencesoptions?: true
    violencetype?: true
    _all?: true
  }

  export type OccurrenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Occurrence to aggregate.
     */
    where?: OccurrenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Occurrences to fetch.
     */
    orderBy?: OccurrenceOrderByWithRelationInput | OccurrenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: OccurrenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Occurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Occurrences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Occurrences
    **/
    _count?: true | OccurrenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: OccurrenceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: OccurrenceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: OccurrenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: OccurrenceMaxAggregateInputType
  }

  export type GetOccurrenceAggregateType<T extends OccurrenceAggregateArgs> = {
        [P in keyof T & keyof AggregateOccurrence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateOccurrence[P]>
      : GetScalarType<T[P], AggregateOccurrence[P]>
  }




  export type OccurrenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: OccurrenceWhereInput
    orderBy?: OccurrenceOrderByWithAggregationInput | OccurrenceOrderByWithAggregationInput[]
    by: OccurrenceScalarFieldEnum[] | OccurrenceScalarFieldEnum
    having?: OccurrenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: OccurrenceCountAggregateInputType | true
    _avg?: OccurrenceAvgAggregateInputType
    _sum?: OccurrenceSumAggregateInputType
    _min?: OccurrenceMinAggregateInputType
    _max?: OccurrenceMaxAggregateInputType
  }

  export type OccurrenceGroupByOutputType = {
    id_occurrence: bigint
    id_user: bigint
    datetime_submission: Date
    State_violence: string | null
    date_violence: Date | null
    time_violence: Date | null
    agegroup: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    violencesoptions: string | null
    violencetype: string | null
    _count: OccurrenceCountAggregateOutputType | null
    _avg: OccurrenceAvgAggregateOutputType | null
    _sum: OccurrenceSumAggregateOutputType | null
    _min: OccurrenceMinAggregateOutputType | null
    _max: OccurrenceMaxAggregateOutputType | null
  }

  type GetOccurrenceGroupByPayload<T extends OccurrenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<OccurrenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof OccurrenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], OccurrenceGroupByOutputType[P]>
            : GetScalarType<T[P], OccurrenceGroupByOutputType[P]>
        }
      >
    >


  export type OccurrenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_occurrence?: boolean
    id_user?: boolean
    datetime_submission?: boolean
    State_violence?: boolean
    date_violence?: boolean
    time_violence?: boolean
    agegroup?: boolean
    latitude?: boolean
    longitude?: boolean
    violencesoptions?: boolean
    violencetype?: boolean
    User?: boolean | UserIPDefaultArgs<ExtArgs>
    StateList?: boolean | Occurrence$StateListArgs<ExtArgs>
    UserOccurrences?: boolean | Occurrence$UserOccurrencesArgs<ExtArgs>
  }, ExtArgs["result"]["occurrence"]>

  export type OccurrenceSelectScalar = {
    id_occurrence?: boolean
    id_user?: boolean
    datetime_submission?: boolean
    State_violence?: boolean
    date_violence?: boolean
    time_violence?: boolean
    agegroup?: boolean
    latitude?: boolean
    longitude?: boolean
    violencesoptions?: boolean
    violencetype?: boolean
  }


  export type OccurrenceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | UserIPDefaultArgs<ExtArgs>
    StateList?: boolean | Occurrence$StateListArgs<ExtArgs>
    UserOccurrences?: boolean | Occurrence$UserOccurrencesArgs<ExtArgs>
  }


  export type $OccurrencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Occurrence"
    objects: {
      User: Prisma.$UserIPPayload<ExtArgs>
      StateList: Prisma.$StateListPayload<ExtArgs> | null
      UserOccurrences: Prisma.$UserOccurrencesPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id_occurrence: bigint
      id_user: bigint
      datetime_submission: Date
      State_violence: string | null
      date_violence: Date | null
      time_violence: Date | null
      agegroup: string | null
      latitude: Prisma.Decimal | null
      longitude: Prisma.Decimal | null
      violencesoptions: string | null
      violencetype: string | null
    }, ExtArgs["result"]["occurrence"]>
    composites: {}
  }


  type OccurrenceGetPayload<S extends boolean | null | undefined | OccurrenceDefaultArgs> = $Result.GetResult<Prisma.$OccurrencePayload, S>

  type OccurrenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<OccurrenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: OccurrenceCountAggregateInputType | true
    }

  export interface OccurrenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Occurrence'], meta: { name: 'Occurrence' } }
    /**
     * Find zero or one Occurrence that matches the filter.
     * @param {OccurrenceFindUniqueArgs} args - Arguments to find a Occurrence
     * @example
     * // Get one Occurrence
     * const occurrence = await prisma.occurrence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends OccurrenceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, OccurrenceFindUniqueArgs<ExtArgs>>
    ): Prisma__OccurrenceClient<$Result.GetResult<Prisma.$OccurrencePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Occurrence that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {OccurrenceFindUniqueOrThrowArgs} args - Arguments to find a Occurrence
     * @example
     * // Get one Occurrence
     * const occurrence = await prisma.occurrence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends OccurrenceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OccurrenceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__OccurrenceClient<$Result.GetResult<Prisma.$OccurrencePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Occurrence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccurrenceFindFirstArgs} args - Arguments to find a Occurrence
     * @example
     * // Get one Occurrence
     * const occurrence = await prisma.occurrence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends OccurrenceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, OccurrenceFindFirstArgs<ExtArgs>>
    ): Prisma__OccurrenceClient<$Result.GetResult<Prisma.$OccurrencePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Occurrence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccurrenceFindFirstOrThrowArgs} args - Arguments to find a Occurrence
     * @example
     * // Get one Occurrence
     * const occurrence = await prisma.occurrence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends OccurrenceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, OccurrenceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__OccurrenceClient<$Result.GetResult<Prisma.$OccurrencePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Occurrences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccurrenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Occurrences
     * const occurrences = await prisma.occurrence.findMany()
     * 
     * // Get first 10 Occurrences
     * const occurrences = await prisma.occurrence.findMany({ take: 10 })
     * 
     * // Only select the `id_occurrence`
     * const occurrenceWithId_occurrenceOnly = await prisma.occurrence.findMany({ select: { id_occurrence: true } })
     * 
    **/
    findMany<T extends OccurrenceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OccurrenceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OccurrencePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Occurrence.
     * @param {OccurrenceCreateArgs} args - Arguments to create a Occurrence.
     * @example
     * // Create one Occurrence
     * const Occurrence = await prisma.occurrence.create({
     *   data: {
     *     // ... data to create a Occurrence
     *   }
     * })
     * 
    **/
    create<T extends OccurrenceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, OccurrenceCreateArgs<ExtArgs>>
    ): Prisma__OccurrenceClient<$Result.GetResult<Prisma.$OccurrencePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Occurrences.
     * @param {OccurrenceCreateManyArgs} args - Arguments to create many Occurrences.
     * @example
     * // Create many Occurrences
     * const occurrence = await prisma.occurrence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends OccurrenceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OccurrenceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Occurrence.
     * @param {OccurrenceDeleteArgs} args - Arguments to delete one Occurrence.
     * @example
     * // Delete one Occurrence
     * const Occurrence = await prisma.occurrence.delete({
     *   where: {
     *     // ... filter to delete one Occurrence
     *   }
     * })
     * 
    **/
    delete<T extends OccurrenceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, OccurrenceDeleteArgs<ExtArgs>>
    ): Prisma__OccurrenceClient<$Result.GetResult<Prisma.$OccurrencePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Occurrence.
     * @param {OccurrenceUpdateArgs} args - Arguments to update one Occurrence.
     * @example
     * // Update one Occurrence
     * const occurrence = await prisma.occurrence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends OccurrenceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, OccurrenceUpdateArgs<ExtArgs>>
    ): Prisma__OccurrenceClient<$Result.GetResult<Prisma.$OccurrencePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Occurrences.
     * @param {OccurrenceDeleteManyArgs} args - Arguments to filter Occurrences to delete.
     * @example
     * // Delete a few Occurrences
     * const { count } = await prisma.occurrence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends OccurrenceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, OccurrenceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Occurrences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccurrenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Occurrences
     * const occurrence = await prisma.occurrence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends OccurrenceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, OccurrenceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Occurrence.
     * @param {OccurrenceUpsertArgs} args - Arguments to update or create a Occurrence.
     * @example
     * // Update or create a Occurrence
     * const occurrence = await prisma.occurrence.upsert({
     *   create: {
     *     // ... data to create a Occurrence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Occurrence we want to update
     *   }
     * })
    **/
    upsert<T extends OccurrenceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, OccurrenceUpsertArgs<ExtArgs>>
    ): Prisma__OccurrenceClient<$Result.GetResult<Prisma.$OccurrencePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Occurrences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccurrenceCountArgs} args - Arguments to filter Occurrences to count.
     * @example
     * // Count the number of Occurrences
     * const count = await prisma.occurrence.count({
     *   where: {
     *     // ... the filter for the Occurrences we want to count
     *   }
     * })
    **/
    count<T extends OccurrenceCountArgs>(
      args?: Subset<T, OccurrenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], OccurrenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Occurrence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccurrenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends OccurrenceAggregateArgs>(args: Subset<T, OccurrenceAggregateArgs>): Prisma.PrismaPromise<GetOccurrenceAggregateType<T>>

    /**
     * Group by Occurrence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {OccurrenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends OccurrenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: OccurrenceGroupByArgs['orderBy'] }
        : { orderBy?: OccurrenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, OccurrenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetOccurrenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Occurrence model
   */
  readonly fields: OccurrenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Occurrence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__OccurrenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    User<T extends UserIPDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserIPDefaultArgs<ExtArgs>>): Prisma__UserIPClient<$Result.GetResult<Prisma.$UserIPPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    StateList<T extends Occurrence$StateListArgs<ExtArgs> = {}>(args?: Subset<T, Occurrence$StateListArgs<ExtArgs>>): Prisma__StateListClient<$Result.GetResult<Prisma.$StateListPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    UserOccurrences<T extends Occurrence$UserOccurrencesArgs<ExtArgs> = {}>(args?: Subset<T, Occurrence$UserOccurrencesArgs<ExtArgs>>): Prisma__UserOccurrencesClient<$Result.GetResult<Prisma.$UserOccurrencesPayload<ExtArgs>, T, 'findUniqueOrThrow'> | null, null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Occurrence model
   */ 
  interface OccurrenceFieldRefs {
    readonly id_occurrence: FieldRef<"Occurrence", 'BigInt'>
    readonly id_user: FieldRef<"Occurrence", 'BigInt'>
    readonly datetime_submission: FieldRef<"Occurrence", 'DateTime'>
    readonly State_violence: FieldRef<"Occurrence", 'String'>
    readonly date_violence: FieldRef<"Occurrence", 'DateTime'>
    readonly time_violence: FieldRef<"Occurrence", 'DateTime'>
    readonly agegroup: FieldRef<"Occurrence", 'String'>
    readonly latitude: FieldRef<"Occurrence", 'Decimal'>
    readonly longitude: FieldRef<"Occurrence", 'Decimal'>
    readonly violencesoptions: FieldRef<"Occurrence", 'String'>
    readonly violencetype: FieldRef<"Occurrence", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Occurrence findUnique
   */
  export type OccurrenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occurrence
     */
    select?: OccurrenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccurrenceInclude<ExtArgs> | null
    /**
     * Filter, which Occurrence to fetch.
     */
    where: OccurrenceWhereUniqueInput
  }

  /**
   * Occurrence findUniqueOrThrow
   */
  export type OccurrenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occurrence
     */
    select?: OccurrenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccurrenceInclude<ExtArgs> | null
    /**
     * Filter, which Occurrence to fetch.
     */
    where: OccurrenceWhereUniqueInput
  }

  /**
   * Occurrence findFirst
   */
  export type OccurrenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occurrence
     */
    select?: OccurrenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccurrenceInclude<ExtArgs> | null
    /**
     * Filter, which Occurrence to fetch.
     */
    where?: OccurrenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Occurrences to fetch.
     */
    orderBy?: OccurrenceOrderByWithRelationInput | OccurrenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Occurrences.
     */
    cursor?: OccurrenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Occurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Occurrences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Occurrences.
     */
    distinct?: OccurrenceScalarFieldEnum | OccurrenceScalarFieldEnum[]
  }

  /**
   * Occurrence findFirstOrThrow
   */
  export type OccurrenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occurrence
     */
    select?: OccurrenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccurrenceInclude<ExtArgs> | null
    /**
     * Filter, which Occurrence to fetch.
     */
    where?: OccurrenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Occurrences to fetch.
     */
    orderBy?: OccurrenceOrderByWithRelationInput | OccurrenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Occurrences.
     */
    cursor?: OccurrenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Occurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Occurrences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Occurrences.
     */
    distinct?: OccurrenceScalarFieldEnum | OccurrenceScalarFieldEnum[]
  }

  /**
   * Occurrence findMany
   */
  export type OccurrenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occurrence
     */
    select?: OccurrenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccurrenceInclude<ExtArgs> | null
    /**
     * Filter, which Occurrences to fetch.
     */
    where?: OccurrenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Occurrences to fetch.
     */
    orderBy?: OccurrenceOrderByWithRelationInput | OccurrenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Occurrences.
     */
    cursor?: OccurrenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Occurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Occurrences.
     */
    skip?: number
    distinct?: OccurrenceScalarFieldEnum | OccurrenceScalarFieldEnum[]
  }

  /**
   * Occurrence create
   */
  export type OccurrenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occurrence
     */
    select?: OccurrenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccurrenceInclude<ExtArgs> | null
    /**
     * The data needed to create a Occurrence.
     */
    data: XOR<OccurrenceCreateInput, OccurrenceUncheckedCreateInput>
  }

  /**
   * Occurrence createMany
   */
  export type OccurrenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Occurrences.
     */
    data: OccurrenceCreateManyInput | OccurrenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Occurrence update
   */
  export type OccurrenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occurrence
     */
    select?: OccurrenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccurrenceInclude<ExtArgs> | null
    /**
     * The data needed to update a Occurrence.
     */
    data: XOR<OccurrenceUpdateInput, OccurrenceUncheckedUpdateInput>
    /**
     * Choose, which Occurrence to update.
     */
    where: OccurrenceWhereUniqueInput
  }

  /**
   * Occurrence updateMany
   */
  export type OccurrenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Occurrences.
     */
    data: XOR<OccurrenceUpdateManyMutationInput, OccurrenceUncheckedUpdateManyInput>
    /**
     * Filter which Occurrences to update
     */
    where?: OccurrenceWhereInput
  }

  /**
   * Occurrence upsert
   */
  export type OccurrenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occurrence
     */
    select?: OccurrenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccurrenceInclude<ExtArgs> | null
    /**
     * The filter to search for the Occurrence to update in case it exists.
     */
    where: OccurrenceWhereUniqueInput
    /**
     * In case the Occurrence found by the `where` argument doesn't exist, create a new Occurrence with this data.
     */
    create: XOR<OccurrenceCreateInput, OccurrenceUncheckedCreateInput>
    /**
     * In case the Occurrence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<OccurrenceUpdateInput, OccurrenceUncheckedUpdateInput>
  }

  /**
   * Occurrence delete
   */
  export type OccurrenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occurrence
     */
    select?: OccurrenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccurrenceInclude<ExtArgs> | null
    /**
     * Filter which Occurrence to delete.
     */
    where: OccurrenceWhereUniqueInput
  }

  /**
   * Occurrence deleteMany
   */
  export type OccurrenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Occurrences to delete
     */
    where?: OccurrenceWhereInput
  }

  /**
   * Occurrence.StateList
   */
  export type Occurrence$StateListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateList
     */
    select?: StateListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateListInclude<ExtArgs> | null
    where?: StateListWhereInput
  }

  /**
   * Occurrence.UserOccurrences
   */
  export type Occurrence$UserOccurrencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOccurrences
     */
    select?: UserOccurrencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOccurrencesInclude<ExtArgs> | null
    where?: UserOccurrencesWhereInput
  }

  /**
   * Occurrence without action
   */
  export type OccurrenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occurrence
     */
    select?: OccurrenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccurrenceInclude<ExtArgs> | null
  }


  /**
   * Model TypesOfViolence
   */

  export type AggregateTypesOfViolence = {
    _count: TypesOfViolenceCountAggregateOutputType | null
    _min: TypesOfViolenceMinAggregateOutputType | null
    _max: TypesOfViolenceMaxAggregateOutputType | null
  }

  export type TypesOfViolenceMinAggregateOutputType = {
    id_violencetype: string | null
    Description: string | null
  }

  export type TypesOfViolenceMaxAggregateOutputType = {
    id_violencetype: string | null
    Description: string | null
  }

  export type TypesOfViolenceCountAggregateOutputType = {
    id_violencetype: number
    Description: number
    _all: number
  }


  export type TypesOfViolenceMinAggregateInputType = {
    id_violencetype?: true
    Description?: true
  }

  export type TypesOfViolenceMaxAggregateInputType = {
    id_violencetype?: true
    Description?: true
  }

  export type TypesOfViolenceCountAggregateInputType = {
    id_violencetype?: true
    Description?: true
    _all?: true
  }

  export type TypesOfViolenceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TypesOfViolence to aggregate.
     */
    where?: TypesOfViolenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypesOfViolences to fetch.
     */
    orderBy?: TypesOfViolenceOrderByWithRelationInput | TypesOfViolenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TypesOfViolenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypesOfViolences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypesOfViolences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TypesOfViolences
    **/
    _count?: true | TypesOfViolenceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TypesOfViolenceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TypesOfViolenceMaxAggregateInputType
  }

  export type GetTypesOfViolenceAggregateType<T extends TypesOfViolenceAggregateArgs> = {
        [P in keyof T & keyof AggregateTypesOfViolence]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTypesOfViolence[P]>
      : GetScalarType<T[P], AggregateTypesOfViolence[P]>
  }




  export type TypesOfViolenceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TypesOfViolenceWhereInput
    orderBy?: TypesOfViolenceOrderByWithAggregationInput | TypesOfViolenceOrderByWithAggregationInput[]
    by: TypesOfViolenceScalarFieldEnum[] | TypesOfViolenceScalarFieldEnum
    having?: TypesOfViolenceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TypesOfViolenceCountAggregateInputType | true
    _min?: TypesOfViolenceMinAggregateInputType
    _max?: TypesOfViolenceMaxAggregateInputType
  }

  export type TypesOfViolenceGroupByOutputType = {
    id_violencetype: string
    Description: string
    _count: TypesOfViolenceCountAggregateOutputType | null
    _min: TypesOfViolenceMinAggregateOutputType | null
    _max: TypesOfViolenceMaxAggregateOutputType | null
  }

  type GetTypesOfViolenceGroupByPayload<T extends TypesOfViolenceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TypesOfViolenceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TypesOfViolenceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TypesOfViolenceGroupByOutputType[P]>
            : GetScalarType<T[P], TypesOfViolenceGroupByOutputType[P]>
        }
      >
    >


  export type TypesOfViolenceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_violencetype?: boolean
    Description?: boolean
  }, ExtArgs["result"]["typesOfViolence"]>

  export type TypesOfViolenceSelectScalar = {
    id_violencetype?: boolean
    Description?: boolean
  }



  export type $TypesOfViolencePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TypesOfViolence"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_violencetype: string
      Description: string
    }, ExtArgs["result"]["typesOfViolence"]>
    composites: {}
  }


  type TypesOfViolenceGetPayload<S extends boolean | null | undefined | TypesOfViolenceDefaultArgs> = $Result.GetResult<Prisma.$TypesOfViolencePayload, S>

  type TypesOfViolenceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TypesOfViolenceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TypesOfViolenceCountAggregateInputType | true
    }

  export interface TypesOfViolenceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TypesOfViolence'], meta: { name: 'TypesOfViolence' } }
    /**
     * Find zero or one TypesOfViolence that matches the filter.
     * @param {TypesOfViolenceFindUniqueArgs} args - Arguments to find a TypesOfViolence
     * @example
     * // Get one TypesOfViolence
     * const typesOfViolence = await prisma.typesOfViolence.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends TypesOfViolenceFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, TypesOfViolenceFindUniqueArgs<ExtArgs>>
    ): Prisma__TypesOfViolenceClient<$Result.GetResult<Prisma.$TypesOfViolencePayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one TypesOfViolence that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TypesOfViolenceFindUniqueOrThrowArgs} args - Arguments to find a TypesOfViolence
     * @example
     * // Get one TypesOfViolence
     * const typesOfViolence = await prisma.typesOfViolence.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends TypesOfViolenceFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TypesOfViolenceFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__TypesOfViolenceClient<$Result.GetResult<Prisma.$TypesOfViolencePayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first TypesOfViolence that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfViolenceFindFirstArgs} args - Arguments to find a TypesOfViolence
     * @example
     * // Get one TypesOfViolence
     * const typesOfViolence = await prisma.typesOfViolence.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends TypesOfViolenceFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, TypesOfViolenceFindFirstArgs<ExtArgs>>
    ): Prisma__TypesOfViolenceClient<$Result.GetResult<Prisma.$TypesOfViolencePayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first TypesOfViolence that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfViolenceFindFirstOrThrowArgs} args - Arguments to find a TypesOfViolence
     * @example
     * // Get one TypesOfViolence
     * const typesOfViolence = await prisma.typesOfViolence.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends TypesOfViolenceFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, TypesOfViolenceFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__TypesOfViolenceClient<$Result.GetResult<Prisma.$TypesOfViolencePayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more TypesOfViolences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfViolenceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TypesOfViolences
     * const typesOfViolences = await prisma.typesOfViolence.findMany()
     * 
     * // Get first 10 TypesOfViolences
     * const typesOfViolences = await prisma.typesOfViolence.findMany({ take: 10 })
     * 
     * // Only select the `id_violencetype`
     * const typesOfViolenceWithId_violencetypeOnly = await prisma.typesOfViolence.findMany({ select: { id_violencetype: true } })
     * 
    **/
    findMany<T extends TypesOfViolenceFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TypesOfViolenceFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TypesOfViolencePayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a TypesOfViolence.
     * @param {TypesOfViolenceCreateArgs} args - Arguments to create a TypesOfViolence.
     * @example
     * // Create one TypesOfViolence
     * const TypesOfViolence = await prisma.typesOfViolence.create({
     *   data: {
     *     // ... data to create a TypesOfViolence
     *   }
     * })
     * 
    **/
    create<T extends TypesOfViolenceCreateArgs<ExtArgs>>(
      args: SelectSubset<T, TypesOfViolenceCreateArgs<ExtArgs>>
    ): Prisma__TypesOfViolenceClient<$Result.GetResult<Prisma.$TypesOfViolencePayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many TypesOfViolences.
     * @param {TypesOfViolenceCreateManyArgs} args - Arguments to create many TypesOfViolences.
     * @example
     * // Create many TypesOfViolences
     * const typesOfViolence = await prisma.typesOfViolence.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends TypesOfViolenceCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TypesOfViolenceCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TypesOfViolence.
     * @param {TypesOfViolenceDeleteArgs} args - Arguments to delete one TypesOfViolence.
     * @example
     * // Delete one TypesOfViolence
     * const TypesOfViolence = await prisma.typesOfViolence.delete({
     *   where: {
     *     // ... filter to delete one TypesOfViolence
     *   }
     * })
     * 
    **/
    delete<T extends TypesOfViolenceDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, TypesOfViolenceDeleteArgs<ExtArgs>>
    ): Prisma__TypesOfViolenceClient<$Result.GetResult<Prisma.$TypesOfViolencePayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one TypesOfViolence.
     * @param {TypesOfViolenceUpdateArgs} args - Arguments to update one TypesOfViolence.
     * @example
     * // Update one TypesOfViolence
     * const typesOfViolence = await prisma.typesOfViolence.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends TypesOfViolenceUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, TypesOfViolenceUpdateArgs<ExtArgs>>
    ): Prisma__TypesOfViolenceClient<$Result.GetResult<Prisma.$TypesOfViolencePayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more TypesOfViolences.
     * @param {TypesOfViolenceDeleteManyArgs} args - Arguments to filter TypesOfViolences to delete.
     * @example
     * // Delete a few TypesOfViolences
     * const { count } = await prisma.typesOfViolence.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends TypesOfViolenceDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, TypesOfViolenceDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TypesOfViolences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfViolenceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TypesOfViolences
     * const typesOfViolence = await prisma.typesOfViolence.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends TypesOfViolenceUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, TypesOfViolenceUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TypesOfViolence.
     * @param {TypesOfViolenceUpsertArgs} args - Arguments to update or create a TypesOfViolence.
     * @example
     * // Update or create a TypesOfViolence
     * const typesOfViolence = await prisma.typesOfViolence.upsert({
     *   create: {
     *     // ... data to create a TypesOfViolence
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TypesOfViolence we want to update
     *   }
     * })
    **/
    upsert<T extends TypesOfViolenceUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, TypesOfViolenceUpsertArgs<ExtArgs>>
    ): Prisma__TypesOfViolenceClient<$Result.GetResult<Prisma.$TypesOfViolencePayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of TypesOfViolences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfViolenceCountArgs} args - Arguments to filter TypesOfViolences to count.
     * @example
     * // Count the number of TypesOfViolences
     * const count = await prisma.typesOfViolence.count({
     *   where: {
     *     // ... the filter for the TypesOfViolences we want to count
     *   }
     * })
    **/
    count<T extends TypesOfViolenceCountArgs>(
      args?: Subset<T, TypesOfViolenceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TypesOfViolenceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TypesOfViolence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfViolenceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TypesOfViolenceAggregateArgs>(args: Subset<T, TypesOfViolenceAggregateArgs>): Prisma.PrismaPromise<GetTypesOfViolenceAggregateType<T>>

    /**
     * Group by TypesOfViolence.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TypesOfViolenceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TypesOfViolenceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TypesOfViolenceGroupByArgs['orderBy'] }
        : { orderBy?: TypesOfViolenceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TypesOfViolenceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTypesOfViolenceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TypesOfViolence model
   */
  readonly fields: TypesOfViolenceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TypesOfViolence.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TypesOfViolenceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the TypesOfViolence model
   */ 
  interface TypesOfViolenceFieldRefs {
    readonly id_violencetype: FieldRef<"TypesOfViolence", 'String'>
    readonly Description: FieldRef<"TypesOfViolence", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TypesOfViolence findUnique
   */
  export type TypesOfViolenceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfViolence
     */
    select?: TypesOfViolenceSelect<ExtArgs> | null
    /**
     * Filter, which TypesOfViolence to fetch.
     */
    where: TypesOfViolenceWhereUniqueInput
  }

  /**
   * TypesOfViolence findUniqueOrThrow
   */
  export type TypesOfViolenceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfViolence
     */
    select?: TypesOfViolenceSelect<ExtArgs> | null
    /**
     * Filter, which TypesOfViolence to fetch.
     */
    where: TypesOfViolenceWhereUniqueInput
  }

  /**
   * TypesOfViolence findFirst
   */
  export type TypesOfViolenceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfViolence
     */
    select?: TypesOfViolenceSelect<ExtArgs> | null
    /**
     * Filter, which TypesOfViolence to fetch.
     */
    where?: TypesOfViolenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypesOfViolences to fetch.
     */
    orderBy?: TypesOfViolenceOrderByWithRelationInput | TypesOfViolenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypesOfViolences.
     */
    cursor?: TypesOfViolenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypesOfViolences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypesOfViolences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypesOfViolences.
     */
    distinct?: TypesOfViolenceScalarFieldEnum | TypesOfViolenceScalarFieldEnum[]
  }

  /**
   * TypesOfViolence findFirstOrThrow
   */
  export type TypesOfViolenceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfViolence
     */
    select?: TypesOfViolenceSelect<ExtArgs> | null
    /**
     * Filter, which TypesOfViolence to fetch.
     */
    where?: TypesOfViolenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypesOfViolences to fetch.
     */
    orderBy?: TypesOfViolenceOrderByWithRelationInput | TypesOfViolenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TypesOfViolences.
     */
    cursor?: TypesOfViolenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypesOfViolences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypesOfViolences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TypesOfViolences.
     */
    distinct?: TypesOfViolenceScalarFieldEnum | TypesOfViolenceScalarFieldEnum[]
  }

  /**
   * TypesOfViolence findMany
   */
  export type TypesOfViolenceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfViolence
     */
    select?: TypesOfViolenceSelect<ExtArgs> | null
    /**
     * Filter, which TypesOfViolences to fetch.
     */
    where?: TypesOfViolenceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TypesOfViolences to fetch.
     */
    orderBy?: TypesOfViolenceOrderByWithRelationInput | TypesOfViolenceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TypesOfViolences.
     */
    cursor?: TypesOfViolenceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TypesOfViolences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TypesOfViolences.
     */
    skip?: number
    distinct?: TypesOfViolenceScalarFieldEnum | TypesOfViolenceScalarFieldEnum[]
  }

  /**
   * TypesOfViolence create
   */
  export type TypesOfViolenceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfViolence
     */
    select?: TypesOfViolenceSelect<ExtArgs> | null
    /**
     * The data needed to create a TypesOfViolence.
     */
    data: XOR<TypesOfViolenceCreateInput, TypesOfViolenceUncheckedCreateInput>
  }

  /**
   * TypesOfViolence createMany
   */
  export type TypesOfViolenceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TypesOfViolences.
     */
    data: TypesOfViolenceCreateManyInput | TypesOfViolenceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TypesOfViolence update
   */
  export type TypesOfViolenceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfViolence
     */
    select?: TypesOfViolenceSelect<ExtArgs> | null
    /**
     * The data needed to update a TypesOfViolence.
     */
    data: XOR<TypesOfViolenceUpdateInput, TypesOfViolenceUncheckedUpdateInput>
    /**
     * Choose, which TypesOfViolence to update.
     */
    where: TypesOfViolenceWhereUniqueInput
  }

  /**
   * TypesOfViolence updateMany
   */
  export type TypesOfViolenceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TypesOfViolences.
     */
    data: XOR<TypesOfViolenceUpdateManyMutationInput, TypesOfViolenceUncheckedUpdateManyInput>
    /**
     * Filter which TypesOfViolences to update
     */
    where?: TypesOfViolenceWhereInput
  }

  /**
   * TypesOfViolence upsert
   */
  export type TypesOfViolenceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfViolence
     */
    select?: TypesOfViolenceSelect<ExtArgs> | null
    /**
     * The filter to search for the TypesOfViolence to update in case it exists.
     */
    where: TypesOfViolenceWhereUniqueInput
    /**
     * In case the TypesOfViolence found by the `where` argument doesn't exist, create a new TypesOfViolence with this data.
     */
    create: XOR<TypesOfViolenceCreateInput, TypesOfViolenceUncheckedCreateInput>
    /**
     * In case the TypesOfViolence was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TypesOfViolenceUpdateInput, TypesOfViolenceUncheckedUpdateInput>
  }

  /**
   * TypesOfViolence delete
   */
  export type TypesOfViolenceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfViolence
     */
    select?: TypesOfViolenceSelect<ExtArgs> | null
    /**
     * Filter which TypesOfViolence to delete.
     */
    where: TypesOfViolenceWhereUniqueInput
  }

  /**
   * TypesOfViolence deleteMany
   */
  export type TypesOfViolenceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TypesOfViolences to delete
     */
    where?: TypesOfViolenceWhereInput
  }

  /**
   * TypesOfViolence without action
   */
  export type TypesOfViolenceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TypesOfViolence
     */
    select?: TypesOfViolenceSelect<ExtArgs> | null
  }


  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id_user: string | null
  }

  export type UserMaxAggregateOutputType = {
    id_user: string | null
  }

  export type UserCountAggregateOutputType = {
    id_user: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id_user?: true
  }

  export type UserMaxAggregateInputType = {
    id_user?: true
  }

  export type UserCountAggregateInputType = {
    id_user?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id_user: string
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_user?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id_user?: boolean
  }



  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_user: string
    }, ExtArgs["result"]["user"]>
    composites: {}
  }


  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id_user`
     * const userWithId_userOnly = await prisma.user.findMany({ select: { id_user: true } })
     * 
    **/
    findMany<T extends UserFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
    **/
    create<T extends UserCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserCreateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends UserCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
    **/
    delete<T extends UserDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserDeleteArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
    **/
    upsert<T extends UserUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserUpsertArgs<ExtArgs>>
    ): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id_user: FieldRef<"User", 'String'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
  }


  /**
   * Model UserIP
   */

  export type AggregateUserIP = {
    _count: UserIPCountAggregateOutputType | null
    _avg: UserIPAvgAggregateOutputType | null
    _sum: UserIPSumAggregateOutputType | null
    _min: UserIPMinAggregateOutputType | null
    _max: UserIPMaxAggregateOutputType | null
  }

  export type UserIPAvgAggregateOutputType = {
    id: number | null
  }

  export type UserIPSumAggregateOutputType = {
    id: bigint | null
  }

  export type UserIPMinAggregateOutputType = {
    id: bigint | null
    ip: string | null
    data: Date | null
  }

  export type UserIPMaxAggregateOutputType = {
    id: bigint | null
    ip: string | null
    data: Date | null
  }

  export type UserIPCountAggregateOutputType = {
    id: number
    ip: number
    data: number
    _all: number
  }


  export type UserIPAvgAggregateInputType = {
    id?: true
  }

  export type UserIPSumAggregateInputType = {
    id?: true
  }

  export type UserIPMinAggregateInputType = {
    id?: true
    ip?: true
    data?: true
  }

  export type UserIPMaxAggregateInputType = {
    id?: true
    ip?: true
    data?: true
  }

  export type UserIPCountAggregateInputType = {
    id?: true
    ip?: true
    data?: true
    _all?: true
  }

  export type UserIPAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserIP to aggregate.
     */
    where?: UserIPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIPS to fetch.
     */
    orderBy?: UserIPOrderByWithRelationInput | UserIPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserIPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserIPS
    **/
    _count?: true | UserIPCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserIPAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserIPSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserIPMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserIPMaxAggregateInputType
  }

  export type GetUserIPAggregateType<T extends UserIPAggregateArgs> = {
        [P in keyof T & keyof AggregateUserIP]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserIP[P]>
      : GetScalarType<T[P], AggregateUserIP[P]>
  }




  export type UserIPGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserIPWhereInput
    orderBy?: UserIPOrderByWithAggregationInput | UserIPOrderByWithAggregationInput[]
    by: UserIPScalarFieldEnum[] | UserIPScalarFieldEnum
    having?: UserIPScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserIPCountAggregateInputType | true
    _avg?: UserIPAvgAggregateInputType
    _sum?: UserIPSumAggregateInputType
    _min?: UserIPMinAggregateInputType
    _max?: UserIPMaxAggregateInputType
  }

  export type UserIPGroupByOutputType = {
    id: bigint
    ip: string
    data: Date
    _count: UserIPCountAggregateOutputType | null
    _avg: UserIPAvgAggregateOutputType | null
    _sum: UserIPSumAggregateOutputType | null
    _min: UserIPMinAggregateOutputType | null
    _max: UserIPMaxAggregateOutputType | null
  }

  type GetUserIPGroupByPayload<T extends UserIPGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserIPGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserIPGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserIPGroupByOutputType[P]>
            : GetScalarType<T[P], UserIPGroupByOutputType[P]>
        }
      >
    >


  export type UserIPSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    ip?: boolean
    data?: boolean
    Occurrence?: boolean | UserIP$OccurrenceArgs<ExtArgs>
    UserOccurrences?: boolean | UserIP$UserOccurrencesArgs<ExtArgs>
    _count?: boolean | UserIPCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userIP"]>

  export type UserIPSelectScalar = {
    id?: boolean
    ip?: boolean
    data?: boolean
  }


  export type UserIPInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Occurrence?: boolean | UserIP$OccurrenceArgs<ExtArgs>
    UserOccurrences?: boolean | UserIP$UserOccurrencesArgs<ExtArgs>
    _count?: boolean | UserIPCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $UserIPPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserIP"
    objects: {
      Occurrence: Prisma.$OccurrencePayload<ExtArgs>[]
      UserOccurrences: Prisma.$UserOccurrencesPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: bigint
      ip: string
      data: Date
    }, ExtArgs["result"]["userIP"]>
    composites: {}
  }


  type UserIPGetPayload<S extends boolean | null | undefined | UserIPDefaultArgs> = $Result.GetResult<Prisma.$UserIPPayload, S>

  type UserIPCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserIPFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserIPCountAggregateInputType | true
    }

  export interface UserIPDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserIP'], meta: { name: 'UserIP' } }
    /**
     * Find zero or one UserIP that matches the filter.
     * @param {UserIPFindUniqueArgs} args - Arguments to find a UserIP
     * @example
     * // Get one UserIP
     * const userIP = await prisma.userIP.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserIPFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserIPFindUniqueArgs<ExtArgs>>
    ): Prisma__UserIPClient<$Result.GetResult<Prisma.$UserIPPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserIP that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserIPFindUniqueOrThrowArgs} args - Arguments to find a UserIP
     * @example
     * // Get one UserIP
     * const userIP = await prisma.userIP.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserIPFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserIPFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserIPClient<$Result.GetResult<Prisma.$UserIPPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserIP that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIPFindFirstArgs} args - Arguments to find a UserIP
     * @example
     * // Get one UserIP
     * const userIP = await prisma.userIP.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserIPFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserIPFindFirstArgs<ExtArgs>>
    ): Prisma__UserIPClient<$Result.GetResult<Prisma.$UserIPPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserIP that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIPFindFirstOrThrowArgs} args - Arguments to find a UserIP
     * @example
     * // Get one UserIP
     * const userIP = await prisma.userIP.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserIPFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserIPFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserIPClient<$Result.GetResult<Prisma.$UserIPPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserIPS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIPFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserIPS
     * const userIPS = await prisma.userIP.findMany()
     * 
     * // Get first 10 UserIPS
     * const userIPS = await prisma.userIP.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userIPWithIdOnly = await prisma.userIP.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends UserIPFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserIPFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserIPPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserIP.
     * @param {UserIPCreateArgs} args - Arguments to create a UserIP.
     * @example
     * // Create one UserIP
     * const UserIP = await prisma.userIP.create({
     *   data: {
     *     // ... data to create a UserIP
     *   }
     * })
     * 
    **/
    create<T extends UserIPCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserIPCreateArgs<ExtArgs>>
    ): Prisma__UserIPClient<$Result.GetResult<Prisma.$UserIPPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserIPS.
     * @param {UserIPCreateManyArgs} args - Arguments to create many UserIPS.
     * @example
     * // Create many UserIPS
     * const userIP = await prisma.userIP.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends UserIPCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserIPCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserIP.
     * @param {UserIPDeleteArgs} args - Arguments to delete one UserIP.
     * @example
     * // Delete one UserIP
     * const UserIP = await prisma.userIP.delete({
     *   where: {
     *     // ... filter to delete one UserIP
     *   }
     * })
     * 
    **/
    delete<T extends UserIPDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserIPDeleteArgs<ExtArgs>>
    ): Prisma__UserIPClient<$Result.GetResult<Prisma.$UserIPPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserIP.
     * @param {UserIPUpdateArgs} args - Arguments to update one UserIP.
     * @example
     * // Update one UserIP
     * const userIP = await prisma.userIP.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserIPUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserIPUpdateArgs<ExtArgs>>
    ): Prisma__UserIPClient<$Result.GetResult<Prisma.$UserIPPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserIPS.
     * @param {UserIPDeleteManyArgs} args - Arguments to filter UserIPS to delete.
     * @example
     * // Delete a few UserIPS
     * const { count } = await prisma.userIP.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserIPDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserIPDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserIPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIPUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserIPS
     * const userIP = await prisma.userIP.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserIPUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserIPUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserIP.
     * @param {UserIPUpsertArgs} args - Arguments to update or create a UserIP.
     * @example
     * // Update or create a UserIP
     * const userIP = await prisma.userIP.upsert({
     *   create: {
     *     // ... data to create a UserIP
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserIP we want to update
     *   }
     * })
    **/
    upsert<T extends UserIPUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserIPUpsertArgs<ExtArgs>>
    ): Prisma__UserIPClient<$Result.GetResult<Prisma.$UserIPPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserIPS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIPCountArgs} args - Arguments to filter UserIPS to count.
     * @example
     * // Count the number of UserIPS
     * const count = await prisma.userIP.count({
     *   where: {
     *     // ... the filter for the UserIPS we want to count
     *   }
     * })
    **/
    count<T extends UserIPCountArgs>(
      args?: Subset<T, UserIPCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserIPCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserIP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIPAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserIPAggregateArgs>(args: Subset<T, UserIPAggregateArgs>): Prisma.PrismaPromise<GetUserIPAggregateType<T>>

    /**
     * Group by UserIP.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserIPGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserIPGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserIPGroupByArgs['orderBy'] }
        : { orderBy?: UserIPGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserIPGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserIPGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserIP model
   */
  readonly fields: UserIPFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserIP.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserIPClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Occurrence<T extends UserIP$OccurrenceArgs<ExtArgs> = {}>(args?: Subset<T, UserIP$OccurrenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OccurrencePayload<ExtArgs>, T, 'findMany'> | Null>;

    UserOccurrences<T extends UserIP$UserOccurrencesArgs<ExtArgs> = {}>(args?: Subset<T, UserIP$UserOccurrencesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOccurrencesPayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserIP model
   */ 
  interface UserIPFieldRefs {
    readonly id: FieldRef<"UserIP", 'BigInt'>
    readonly ip: FieldRef<"UserIP", 'String'>
    readonly data: FieldRef<"UserIP", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserIP findUnique
   */
  export type UserIPFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIP
     */
    select?: UserIPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIPInclude<ExtArgs> | null
    /**
     * Filter, which UserIP to fetch.
     */
    where: UserIPWhereUniqueInput
  }

  /**
   * UserIP findUniqueOrThrow
   */
  export type UserIPFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIP
     */
    select?: UserIPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIPInclude<ExtArgs> | null
    /**
     * Filter, which UserIP to fetch.
     */
    where: UserIPWhereUniqueInput
  }

  /**
   * UserIP findFirst
   */
  export type UserIPFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIP
     */
    select?: UserIPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIPInclude<ExtArgs> | null
    /**
     * Filter, which UserIP to fetch.
     */
    where?: UserIPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIPS to fetch.
     */
    orderBy?: UserIPOrderByWithRelationInput | UserIPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserIPS.
     */
    cursor?: UserIPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserIPS.
     */
    distinct?: UserIPScalarFieldEnum | UserIPScalarFieldEnum[]
  }

  /**
   * UserIP findFirstOrThrow
   */
  export type UserIPFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIP
     */
    select?: UserIPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIPInclude<ExtArgs> | null
    /**
     * Filter, which UserIP to fetch.
     */
    where?: UserIPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIPS to fetch.
     */
    orderBy?: UserIPOrderByWithRelationInput | UserIPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserIPS.
     */
    cursor?: UserIPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIPS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserIPS.
     */
    distinct?: UserIPScalarFieldEnum | UserIPScalarFieldEnum[]
  }

  /**
   * UserIP findMany
   */
  export type UserIPFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIP
     */
    select?: UserIPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIPInclude<ExtArgs> | null
    /**
     * Filter, which UserIPS to fetch.
     */
    where?: UserIPWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserIPS to fetch.
     */
    orderBy?: UserIPOrderByWithRelationInput | UserIPOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserIPS.
     */
    cursor?: UserIPWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserIPS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserIPS.
     */
    skip?: number
    distinct?: UserIPScalarFieldEnum | UserIPScalarFieldEnum[]
  }

  /**
   * UserIP create
   */
  export type UserIPCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIP
     */
    select?: UserIPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIPInclude<ExtArgs> | null
    /**
     * The data needed to create a UserIP.
     */
    data: XOR<UserIPCreateInput, UserIPUncheckedCreateInput>
  }

  /**
   * UserIP createMany
   */
  export type UserIPCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserIPS.
     */
    data: UserIPCreateManyInput | UserIPCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserIP update
   */
  export type UserIPUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIP
     */
    select?: UserIPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIPInclude<ExtArgs> | null
    /**
     * The data needed to update a UserIP.
     */
    data: XOR<UserIPUpdateInput, UserIPUncheckedUpdateInput>
    /**
     * Choose, which UserIP to update.
     */
    where: UserIPWhereUniqueInput
  }

  /**
   * UserIP updateMany
   */
  export type UserIPUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserIPS.
     */
    data: XOR<UserIPUpdateManyMutationInput, UserIPUncheckedUpdateManyInput>
    /**
     * Filter which UserIPS to update
     */
    where?: UserIPWhereInput
  }

  /**
   * UserIP upsert
   */
  export type UserIPUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIP
     */
    select?: UserIPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIPInclude<ExtArgs> | null
    /**
     * The filter to search for the UserIP to update in case it exists.
     */
    where: UserIPWhereUniqueInput
    /**
     * In case the UserIP found by the `where` argument doesn't exist, create a new UserIP with this data.
     */
    create: XOR<UserIPCreateInput, UserIPUncheckedCreateInput>
    /**
     * In case the UserIP was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserIPUpdateInput, UserIPUncheckedUpdateInput>
  }

  /**
   * UserIP delete
   */
  export type UserIPDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIP
     */
    select?: UserIPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIPInclude<ExtArgs> | null
    /**
     * Filter which UserIP to delete.
     */
    where: UserIPWhereUniqueInput
  }

  /**
   * UserIP deleteMany
   */
  export type UserIPDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserIPS to delete
     */
    where?: UserIPWhereInput
  }

  /**
   * UserIP.Occurrence
   */
  export type UserIP$OccurrenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occurrence
     */
    select?: OccurrenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccurrenceInclude<ExtArgs> | null
    where?: OccurrenceWhereInput
    orderBy?: OccurrenceOrderByWithRelationInput | OccurrenceOrderByWithRelationInput[]
    cursor?: OccurrenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OccurrenceScalarFieldEnum | OccurrenceScalarFieldEnum[]
  }

  /**
   * UserIP.UserOccurrences
   */
  export type UserIP$UserOccurrencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOccurrences
     */
    select?: UserOccurrencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOccurrencesInclude<ExtArgs> | null
    where?: UserOccurrencesWhereInput
    orderBy?: UserOccurrencesOrderByWithRelationInput | UserOccurrencesOrderByWithRelationInput[]
    cursor?: UserOccurrencesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserOccurrencesScalarFieldEnum | UserOccurrencesScalarFieldEnum[]
  }

  /**
   * UserIP without action
   */
  export type UserIPDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserIP
     */
    select?: UserIPSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserIPInclude<ExtArgs> | null
  }


  /**
   * Model UserOccurrences
   */

  export type AggregateUserOccurrences = {
    _count: UserOccurrencesCountAggregateOutputType | null
    _avg: UserOccurrencesAvgAggregateOutputType | null
    _sum: UserOccurrencesSumAggregateOutputType | null
    _min: UserOccurrencesMinAggregateOutputType | null
    _max: UserOccurrencesMaxAggregateOutputType | null
  }

  export type UserOccurrencesAvgAggregateOutputType = {
    id_occurrence: number | null
    id_user: number | null
  }

  export type UserOccurrencesSumAggregateOutputType = {
    id_occurrence: bigint | null
    id_user: bigint | null
  }

  export type UserOccurrencesMinAggregateOutputType = {
    id_occurrence: bigint | null
    id_user: bigint | null
    date_violence: Date | null
  }

  export type UserOccurrencesMaxAggregateOutputType = {
    id_occurrence: bigint | null
    id_user: bigint | null
    date_violence: Date | null
  }

  export type UserOccurrencesCountAggregateOutputType = {
    id_occurrence: number
    id_user: number
    date_violence: number
    _all: number
  }


  export type UserOccurrencesAvgAggregateInputType = {
    id_occurrence?: true
    id_user?: true
  }

  export type UserOccurrencesSumAggregateInputType = {
    id_occurrence?: true
    id_user?: true
  }

  export type UserOccurrencesMinAggregateInputType = {
    id_occurrence?: true
    id_user?: true
    date_violence?: true
  }

  export type UserOccurrencesMaxAggregateInputType = {
    id_occurrence?: true
    id_user?: true
    date_violence?: true
  }

  export type UserOccurrencesCountAggregateInputType = {
    id_occurrence?: true
    id_user?: true
    date_violence?: true
    _all?: true
  }

  export type UserOccurrencesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserOccurrences to aggregate.
     */
    where?: UserOccurrencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOccurrences to fetch.
     */
    orderBy?: UserOccurrencesOrderByWithRelationInput | UserOccurrencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserOccurrencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOccurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOccurrences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserOccurrences
    **/
    _count?: true | UserOccurrencesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserOccurrencesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserOccurrencesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserOccurrencesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserOccurrencesMaxAggregateInputType
  }

  export type GetUserOccurrencesAggregateType<T extends UserOccurrencesAggregateArgs> = {
        [P in keyof T & keyof AggregateUserOccurrences]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserOccurrences[P]>
      : GetScalarType<T[P], AggregateUserOccurrences[P]>
  }




  export type UserOccurrencesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserOccurrencesWhereInput
    orderBy?: UserOccurrencesOrderByWithAggregationInput | UserOccurrencesOrderByWithAggregationInput[]
    by: UserOccurrencesScalarFieldEnum[] | UserOccurrencesScalarFieldEnum
    having?: UserOccurrencesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserOccurrencesCountAggregateInputType | true
    _avg?: UserOccurrencesAvgAggregateInputType
    _sum?: UserOccurrencesSumAggregateInputType
    _min?: UserOccurrencesMinAggregateInputType
    _max?: UserOccurrencesMaxAggregateInputType
  }

  export type UserOccurrencesGroupByOutputType = {
    id_occurrence: bigint
    id_user: bigint
    date_violence: Date
    _count: UserOccurrencesCountAggregateOutputType | null
    _avg: UserOccurrencesAvgAggregateOutputType | null
    _sum: UserOccurrencesSumAggregateOutputType | null
    _min: UserOccurrencesMinAggregateOutputType | null
    _max: UserOccurrencesMaxAggregateOutputType | null
  }

  type GetUserOccurrencesGroupByPayload<T extends UserOccurrencesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserOccurrencesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserOccurrencesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserOccurrencesGroupByOutputType[P]>
            : GetScalarType<T[P], UserOccurrencesGroupByOutputType[P]>
        }
      >
    >


  export type UserOccurrencesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_occurrence?: boolean
    id_user?: boolean
    date_violence?: boolean
    Occurrence?: boolean | OccurrenceDefaultArgs<ExtArgs>
    User?: boolean | UserIPDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userOccurrences"]>

  export type UserOccurrencesSelectScalar = {
    id_occurrence?: boolean
    id_user?: boolean
    date_violence?: boolean
  }


  export type UserOccurrencesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Occurrence?: boolean | OccurrenceDefaultArgs<ExtArgs>
    User?: boolean | UserIPDefaultArgs<ExtArgs>
  }


  export type $UserOccurrencesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserOccurrences"
    objects: {
      Occurrence: Prisma.$OccurrencePayload<ExtArgs>
      User: Prisma.$UserIPPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id_occurrence: bigint
      id_user: bigint
      date_violence: Date
    }, ExtArgs["result"]["userOccurrences"]>
    composites: {}
  }


  type UserOccurrencesGetPayload<S extends boolean | null | undefined | UserOccurrencesDefaultArgs> = $Result.GetResult<Prisma.$UserOccurrencesPayload, S>

  type UserOccurrencesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserOccurrencesFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserOccurrencesCountAggregateInputType | true
    }

  export interface UserOccurrencesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserOccurrences'], meta: { name: 'UserOccurrences' } }
    /**
     * Find zero or one UserOccurrences that matches the filter.
     * @param {UserOccurrencesFindUniqueArgs} args - Arguments to find a UserOccurrences
     * @example
     * // Get one UserOccurrences
     * const userOccurrences = await prisma.userOccurrences.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends UserOccurrencesFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, UserOccurrencesFindUniqueArgs<ExtArgs>>
    ): Prisma__UserOccurrencesClient<$Result.GetResult<Prisma.$UserOccurrencesPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one UserOccurrences that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserOccurrencesFindUniqueOrThrowArgs} args - Arguments to find a UserOccurrences
     * @example
     * // Get one UserOccurrences
     * const userOccurrences = await prisma.userOccurrences.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends UserOccurrencesFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserOccurrencesFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__UserOccurrencesClient<$Result.GetResult<Prisma.$UserOccurrencesPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first UserOccurrences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOccurrencesFindFirstArgs} args - Arguments to find a UserOccurrences
     * @example
     * // Get one UserOccurrences
     * const userOccurrences = await prisma.userOccurrences.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends UserOccurrencesFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, UserOccurrencesFindFirstArgs<ExtArgs>>
    ): Prisma__UserOccurrencesClient<$Result.GetResult<Prisma.$UserOccurrencesPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first UserOccurrences that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOccurrencesFindFirstOrThrowArgs} args - Arguments to find a UserOccurrences
     * @example
     * // Get one UserOccurrences
     * const userOccurrences = await prisma.userOccurrences.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends UserOccurrencesFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, UserOccurrencesFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__UserOccurrencesClient<$Result.GetResult<Prisma.$UserOccurrencesPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more UserOccurrences that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOccurrencesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserOccurrences
     * const userOccurrences = await prisma.userOccurrences.findMany()
     * 
     * // Get first 10 UserOccurrences
     * const userOccurrences = await prisma.userOccurrences.findMany({ take: 10 })
     * 
     * // Only select the `id_occurrence`
     * const userOccurrencesWithId_occurrenceOnly = await prisma.userOccurrences.findMany({ select: { id_occurrence: true } })
     * 
    **/
    findMany<T extends UserOccurrencesFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserOccurrencesFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserOccurrencesPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a UserOccurrences.
     * @param {UserOccurrencesCreateArgs} args - Arguments to create a UserOccurrences.
     * @example
     * // Create one UserOccurrences
     * const UserOccurrences = await prisma.userOccurrences.create({
     *   data: {
     *     // ... data to create a UserOccurrences
     *   }
     * })
     * 
    **/
    create<T extends UserOccurrencesCreateArgs<ExtArgs>>(
      args: SelectSubset<T, UserOccurrencesCreateArgs<ExtArgs>>
    ): Prisma__UserOccurrencesClient<$Result.GetResult<Prisma.$UserOccurrencesPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many UserOccurrences.
     * @param {UserOccurrencesCreateManyArgs} args - Arguments to create many UserOccurrences.
     * @example
     * // Create many UserOccurrences
     * const userOccurrences = await prisma.userOccurrences.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends UserOccurrencesCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserOccurrencesCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserOccurrences.
     * @param {UserOccurrencesDeleteArgs} args - Arguments to delete one UserOccurrences.
     * @example
     * // Delete one UserOccurrences
     * const UserOccurrences = await prisma.userOccurrences.delete({
     *   where: {
     *     // ... filter to delete one UserOccurrences
     *   }
     * })
     * 
    **/
    delete<T extends UserOccurrencesDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, UserOccurrencesDeleteArgs<ExtArgs>>
    ): Prisma__UserOccurrencesClient<$Result.GetResult<Prisma.$UserOccurrencesPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one UserOccurrences.
     * @param {UserOccurrencesUpdateArgs} args - Arguments to update one UserOccurrences.
     * @example
     * // Update one UserOccurrences
     * const userOccurrences = await prisma.userOccurrences.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends UserOccurrencesUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, UserOccurrencesUpdateArgs<ExtArgs>>
    ): Prisma__UserOccurrencesClient<$Result.GetResult<Prisma.$UserOccurrencesPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more UserOccurrences.
     * @param {UserOccurrencesDeleteManyArgs} args - Arguments to filter UserOccurrences to delete.
     * @example
     * // Delete a few UserOccurrences
     * const { count } = await prisma.userOccurrences.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends UserOccurrencesDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, UserOccurrencesDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserOccurrences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOccurrencesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserOccurrences
     * const userOccurrences = await prisma.userOccurrences.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends UserOccurrencesUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, UserOccurrencesUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserOccurrences.
     * @param {UserOccurrencesUpsertArgs} args - Arguments to update or create a UserOccurrences.
     * @example
     * // Update or create a UserOccurrences
     * const userOccurrences = await prisma.userOccurrences.upsert({
     *   create: {
     *     // ... data to create a UserOccurrences
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserOccurrences we want to update
     *   }
     * })
    **/
    upsert<T extends UserOccurrencesUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, UserOccurrencesUpsertArgs<ExtArgs>>
    ): Prisma__UserOccurrencesClient<$Result.GetResult<Prisma.$UserOccurrencesPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of UserOccurrences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOccurrencesCountArgs} args - Arguments to filter UserOccurrences to count.
     * @example
     * // Count the number of UserOccurrences
     * const count = await prisma.userOccurrences.count({
     *   where: {
     *     // ... the filter for the UserOccurrences we want to count
     *   }
     * })
    **/
    count<T extends UserOccurrencesCountArgs>(
      args?: Subset<T, UserOccurrencesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserOccurrencesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserOccurrences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOccurrencesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserOccurrencesAggregateArgs>(args: Subset<T, UserOccurrencesAggregateArgs>): Prisma.PrismaPromise<GetUserOccurrencesAggregateType<T>>

    /**
     * Group by UserOccurrences.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserOccurrencesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserOccurrencesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserOccurrencesGroupByArgs['orderBy'] }
        : { orderBy?: UserOccurrencesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserOccurrencesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserOccurrencesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserOccurrences model
   */
  readonly fields: UserOccurrencesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserOccurrences.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserOccurrencesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Occurrence<T extends OccurrenceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, OccurrenceDefaultArgs<ExtArgs>>): Prisma__OccurrenceClient<$Result.GetResult<Prisma.$OccurrencePayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    User<T extends UserIPDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserIPDefaultArgs<ExtArgs>>): Prisma__UserIPClient<$Result.GetResult<Prisma.$UserIPPayload<ExtArgs>, T, 'findUniqueOrThrow'> | Null, Null, ExtArgs>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the UserOccurrences model
   */ 
  interface UserOccurrencesFieldRefs {
    readonly id_occurrence: FieldRef<"UserOccurrences", 'BigInt'>
    readonly id_user: FieldRef<"UserOccurrences", 'BigInt'>
    readonly date_violence: FieldRef<"UserOccurrences", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserOccurrences findUnique
   */
  export type UserOccurrencesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOccurrences
     */
    select?: UserOccurrencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOccurrencesInclude<ExtArgs> | null
    /**
     * Filter, which UserOccurrences to fetch.
     */
    where: UserOccurrencesWhereUniqueInput
  }

  /**
   * UserOccurrences findUniqueOrThrow
   */
  export type UserOccurrencesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOccurrences
     */
    select?: UserOccurrencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOccurrencesInclude<ExtArgs> | null
    /**
     * Filter, which UserOccurrences to fetch.
     */
    where: UserOccurrencesWhereUniqueInput
  }

  /**
   * UserOccurrences findFirst
   */
  export type UserOccurrencesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOccurrences
     */
    select?: UserOccurrencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOccurrencesInclude<ExtArgs> | null
    /**
     * Filter, which UserOccurrences to fetch.
     */
    where?: UserOccurrencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOccurrences to fetch.
     */
    orderBy?: UserOccurrencesOrderByWithRelationInput | UserOccurrencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserOccurrences.
     */
    cursor?: UserOccurrencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOccurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOccurrences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserOccurrences.
     */
    distinct?: UserOccurrencesScalarFieldEnum | UserOccurrencesScalarFieldEnum[]
  }

  /**
   * UserOccurrences findFirstOrThrow
   */
  export type UserOccurrencesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOccurrences
     */
    select?: UserOccurrencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOccurrencesInclude<ExtArgs> | null
    /**
     * Filter, which UserOccurrences to fetch.
     */
    where?: UserOccurrencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOccurrences to fetch.
     */
    orderBy?: UserOccurrencesOrderByWithRelationInput | UserOccurrencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserOccurrences.
     */
    cursor?: UserOccurrencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOccurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOccurrences.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserOccurrences.
     */
    distinct?: UserOccurrencesScalarFieldEnum | UserOccurrencesScalarFieldEnum[]
  }

  /**
   * UserOccurrences findMany
   */
  export type UserOccurrencesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOccurrences
     */
    select?: UserOccurrencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOccurrencesInclude<ExtArgs> | null
    /**
     * Filter, which UserOccurrences to fetch.
     */
    where?: UserOccurrencesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserOccurrences to fetch.
     */
    orderBy?: UserOccurrencesOrderByWithRelationInput | UserOccurrencesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserOccurrences.
     */
    cursor?: UserOccurrencesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserOccurrences from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserOccurrences.
     */
    skip?: number
    distinct?: UserOccurrencesScalarFieldEnum | UserOccurrencesScalarFieldEnum[]
  }

  /**
   * UserOccurrences create
   */
  export type UserOccurrencesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOccurrences
     */
    select?: UserOccurrencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOccurrencesInclude<ExtArgs> | null
    /**
     * The data needed to create a UserOccurrences.
     */
    data: XOR<UserOccurrencesCreateInput, UserOccurrencesUncheckedCreateInput>
  }

  /**
   * UserOccurrences createMany
   */
  export type UserOccurrencesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserOccurrences.
     */
    data: UserOccurrencesCreateManyInput | UserOccurrencesCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserOccurrences update
   */
  export type UserOccurrencesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOccurrences
     */
    select?: UserOccurrencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOccurrencesInclude<ExtArgs> | null
    /**
     * The data needed to update a UserOccurrences.
     */
    data: XOR<UserOccurrencesUpdateInput, UserOccurrencesUncheckedUpdateInput>
    /**
     * Choose, which UserOccurrences to update.
     */
    where: UserOccurrencesWhereUniqueInput
  }

  /**
   * UserOccurrences updateMany
   */
  export type UserOccurrencesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserOccurrences.
     */
    data: XOR<UserOccurrencesUpdateManyMutationInput, UserOccurrencesUncheckedUpdateManyInput>
    /**
     * Filter which UserOccurrences to update
     */
    where?: UserOccurrencesWhereInput
  }

  /**
   * UserOccurrences upsert
   */
  export type UserOccurrencesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOccurrences
     */
    select?: UserOccurrencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOccurrencesInclude<ExtArgs> | null
    /**
     * The filter to search for the UserOccurrences to update in case it exists.
     */
    where: UserOccurrencesWhereUniqueInput
    /**
     * In case the UserOccurrences found by the `where` argument doesn't exist, create a new UserOccurrences with this data.
     */
    create: XOR<UserOccurrencesCreateInput, UserOccurrencesUncheckedCreateInput>
    /**
     * In case the UserOccurrences was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserOccurrencesUpdateInput, UserOccurrencesUncheckedUpdateInput>
  }

  /**
   * UserOccurrences delete
   */
  export type UserOccurrencesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOccurrences
     */
    select?: UserOccurrencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOccurrencesInclude<ExtArgs> | null
    /**
     * Filter which UserOccurrences to delete.
     */
    where: UserOccurrencesWhereUniqueInput
  }

  /**
   * UserOccurrences deleteMany
   */
  export type UserOccurrencesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserOccurrences to delete
     */
    where?: UserOccurrencesWhereInput
  }

  /**
   * UserOccurrences without action
   */
  export type UserOccurrencesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserOccurrences
     */
    select?: UserOccurrencesSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserOccurrencesInclude<ExtArgs> | null
  }


  /**
   * Model ViolenceSituations
   */

  export type AggregateViolenceSituations = {
    _count: ViolenceSituationsCountAggregateOutputType | null
    _min: ViolenceSituationsMinAggregateOutputType | null
    _max: ViolenceSituationsMaxAggregateOutputType | null
  }

  export type ViolenceSituationsMinAggregateOutputType = {
    id_violenceoption: string | null
    Description: string | null
  }

  export type ViolenceSituationsMaxAggregateOutputType = {
    id_violenceoption: string | null
    Description: string | null
  }

  export type ViolenceSituationsCountAggregateOutputType = {
    id_violenceoption: number
    Description: number
    _all: number
  }


  export type ViolenceSituationsMinAggregateInputType = {
    id_violenceoption?: true
    Description?: true
  }

  export type ViolenceSituationsMaxAggregateInputType = {
    id_violenceoption?: true
    Description?: true
  }

  export type ViolenceSituationsCountAggregateInputType = {
    id_violenceoption?: true
    Description?: true
    _all?: true
  }

  export type ViolenceSituationsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViolenceSituations to aggregate.
     */
    where?: ViolenceSituationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViolenceSituations to fetch.
     */
    orderBy?: ViolenceSituationsOrderByWithRelationInput | ViolenceSituationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ViolenceSituationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViolenceSituations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViolenceSituations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ViolenceSituations
    **/
    _count?: true | ViolenceSituationsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ViolenceSituationsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ViolenceSituationsMaxAggregateInputType
  }

  export type GetViolenceSituationsAggregateType<T extends ViolenceSituationsAggregateArgs> = {
        [P in keyof T & keyof AggregateViolenceSituations]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateViolenceSituations[P]>
      : GetScalarType<T[P], AggregateViolenceSituations[P]>
  }




  export type ViolenceSituationsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ViolenceSituationsWhereInput
    orderBy?: ViolenceSituationsOrderByWithAggregationInput | ViolenceSituationsOrderByWithAggregationInput[]
    by: ViolenceSituationsScalarFieldEnum[] | ViolenceSituationsScalarFieldEnum
    having?: ViolenceSituationsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ViolenceSituationsCountAggregateInputType | true
    _min?: ViolenceSituationsMinAggregateInputType
    _max?: ViolenceSituationsMaxAggregateInputType
  }

  export type ViolenceSituationsGroupByOutputType = {
    id_violenceoption: string
    Description: string
    _count: ViolenceSituationsCountAggregateOutputType | null
    _min: ViolenceSituationsMinAggregateOutputType | null
    _max: ViolenceSituationsMaxAggregateOutputType | null
  }

  type GetViolenceSituationsGroupByPayload<T extends ViolenceSituationsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ViolenceSituationsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ViolenceSituationsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ViolenceSituationsGroupByOutputType[P]>
            : GetScalarType<T[P], ViolenceSituationsGroupByOutputType[P]>
        }
      >
    >


  export type ViolenceSituationsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_violenceoption?: boolean
    Description?: boolean
  }, ExtArgs["result"]["violenceSituations"]>

  export type ViolenceSituationsSelectScalar = {
    id_violenceoption?: boolean
    Description?: boolean
  }



  export type $ViolenceSituationsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ViolenceSituations"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id_violenceoption: string
      Description: string
    }, ExtArgs["result"]["violenceSituations"]>
    composites: {}
  }


  type ViolenceSituationsGetPayload<S extends boolean | null | undefined | ViolenceSituationsDefaultArgs> = $Result.GetResult<Prisma.$ViolenceSituationsPayload, S>

  type ViolenceSituationsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ViolenceSituationsFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ViolenceSituationsCountAggregateInputType | true
    }

  export interface ViolenceSituationsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ViolenceSituations'], meta: { name: 'ViolenceSituations' } }
    /**
     * Find zero or one ViolenceSituations that matches the filter.
     * @param {ViolenceSituationsFindUniqueArgs} args - Arguments to find a ViolenceSituations
     * @example
     * // Get one ViolenceSituations
     * const violenceSituations = await prisma.violenceSituations.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends ViolenceSituationsFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, ViolenceSituationsFindUniqueArgs<ExtArgs>>
    ): Prisma__ViolenceSituationsClient<$Result.GetResult<Prisma.$ViolenceSituationsPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one ViolenceSituations that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ViolenceSituationsFindUniqueOrThrowArgs} args - Arguments to find a ViolenceSituations
     * @example
     * // Get one ViolenceSituations
     * const violenceSituations = await prisma.violenceSituations.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends ViolenceSituationsFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ViolenceSituationsFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__ViolenceSituationsClient<$Result.GetResult<Prisma.$ViolenceSituationsPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first ViolenceSituations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViolenceSituationsFindFirstArgs} args - Arguments to find a ViolenceSituations
     * @example
     * // Get one ViolenceSituations
     * const violenceSituations = await prisma.violenceSituations.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends ViolenceSituationsFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, ViolenceSituationsFindFirstArgs<ExtArgs>>
    ): Prisma__ViolenceSituationsClient<$Result.GetResult<Prisma.$ViolenceSituationsPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first ViolenceSituations that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViolenceSituationsFindFirstOrThrowArgs} args - Arguments to find a ViolenceSituations
     * @example
     * // Get one ViolenceSituations
     * const violenceSituations = await prisma.violenceSituations.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends ViolenceSituationsFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, ViolenceSituationsFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__ViolenceSituationsClient<$Result.GetResult<Prisma.$ViolenceSituationsPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more ViolenceSituations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViolenceSituationsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ViolenceSituations
     * const violenceSituations = await prisma.violenceSituations.findMany()
     * 
     * // Get first 10 ViolenceSituations
     * const violenceSituations = await prisma.violenceSituations.findMany({ take: 10 })
     * 
     * // Only select the `id_violenceoption`
     * const violenceSituationsWithId_violenceoptionOnly = await prisma.violenceSituations.findMany({ select: { id_violenceoption: true } })
     * 
    **/
    findMany<T extends ViolenceSituationsFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ViolenceSituationsFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ViolenceSituationsPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a ViolenceSituations.
     * @param {ViolenceSituationsCreateArgs} args - Arguments to create a ViolenceSituations.
     * @example
     * // Create one ViolenceSituations
     * const ViolenceSituations = await prisma.violenceSituations.create({
     *   data: {
     *     // ... data to create a ViolenceSituations
     *   }
     * })
     * 
    **/
    create<T extends ViolenceSituationsCreateArgs<ExtArgs>>(
      args: SelectSubset<T, ViolenceSituationsCreateArgs<ExtArgs>>
    ): Prisma__ViolenceSituationsClient<$Result.GetResult<Prisma.$ViolenceSituationsPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many ViolenceSituations.
     * @param {ViolenceSituationsCreateManyArgs} args - Arguments to create many ViolenceSituations.
     * @example
     * // Create many ViolenceSituations
     * const violenceSituations = await prisma.violenceSituations.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends ViolenceSituationsCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ViolenceSituationsCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ViolenceSituations.
     * @param {ViolenceSituationsDeleteArgs} args - Arguments to delete one ViolenceSituations.
     * @example
     * // Delete one ViolenceSituations
     * const ViolenceSituations = await prisma.violenceSituations.delete({
     *   where: {
     *     // ... filter to delete one ViolenceSituations
     *   }
     * })
     * 
    **/
    delete<T extends ViolenceSituationsDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, ViolenceSituationsDeleteArgs<ExtArgs>>
    ): Prisma__ViolenceSituationsClient<$Result.GetResult<Prisma.$ViolenceSituationsPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one ViolenceSituations.
     * @param {ViolenceSituationsUpdateArgs} args - Arguments to update one ViolenceSituations.
     * @example
     * // Update one ViolenceSituations
     * const violenceSituations = await prisma.violenceSituations.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends ViolenceSituationsUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, ViolenceSituationsUpdateArgs<ExtArgs>>
    ): Prisma__ViolenceSituationsClient<$Result.GetResult<Prisma.$ViolenceSituationsPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more ViolenceSituations.
     * @param {ViolenceSituationsDeleteManyArgs} args - Arguments to filter ViolenceSituations to delete.
     * @example
     * // Delete a few ViolenceSituations
     * const { count } = await prisma.violenceSituations.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends ViolenceSituationsDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, ViolenceSituationsDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ViolenceSituations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViolenceSituationsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ViolenceSituations
     * const violenceSituations = await prisma.violenceSituations.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends ViolenceSituationsUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, ViolenceSituationsUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ViolenceSituations.
     * @param {ViolenceSituationsUpsertArgs} args - Arguments to update or create a ViolenceSituations.
     * @example
     * // Update or create a ViolenceSituations
     * const violenceSituations = await prisma.violenceSituations.upsert({
     *   create: {
     *     // ... data to create a ViolenceSituations
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ViolenceSituations we want to update
     *   }
     * })
    **/
    upsert<T extends ViolenceSituationsUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, ViolenceSituationsUpsertArgs<ExtArgs>>
    ): Prisma__ViolenceSituationsClient<$Result.GetResult<Prisma.$ViolenceSituationsPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of ViolenceSituations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViolenceSituationsCountArgs} args - Arguments to filter ViolenceSituations to count.
     * @example
     * // Count the number of ViolenceSituations
     * const count = await prisma.violenceSituations.count({
     *   where: {
     *     // ... the filter for the ViolenceSituations we want to count
     *   }
     * })
    **/
    count<T extends ViolenceSituationsCountArgs>(
      args?: Subset<T, ViolenceSituationsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ViolenceSituationsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ViolenceSituations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViolenceSituationsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ViolenceSituationsAggregateArgs>(args: Subset<T, ViolenceSituationsAggregateArgs>): Prisma.PrismaPromise<GetViolenceSituationsAggregateType<T>>

    /**
     * Group by ViolenceSituations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ViolenceSituationsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ViolenceSituationsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ViolenceSituationsGroupByArgs['orderBy'] }
        : { orderBy?: ViolenceSituationsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ViolenceSituationsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetViolenceSituationsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ViolenceSituations model
   */
  readonly fields: ViolenceSituationsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ViolenceSituations.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ViolenceSituationsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the ViolenceSituations model
   */ 
  interface ViolenceSituationsFieldRefs {
    readonly id_violenceoption: FieldRef<"ViolenceSituations", 'String'>
    readonly Description: FieldRef<"ViolenceSituations", 'String'>
  }
    

  // Custom InputTypes
  /**
   * ViolenceSituations findUnique
   */
  export type ViolenceSituationsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViolenceSituations
     */
    select?: ViolenceSituationsSelect<ExtArgs> | null
    /**
     * Filter, which ViolenceSituations to fetch.
     */
    where: ViolenceSituationsWhereUniqueInput
  }

  /**
   * ViolenceSituations findUniqueOrThrow
   */
  export type ViolenceSituationsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViolenceSituations
     */
    select?: ViolenceSituationsSelect<ExtArgs> | null
    /**
     * Filter, which ViolenceSituations to fetch.
     */
    where: ViolenceSituationsWhereUniqueInput
  }

  /**
   * ViolenceSituations findFirst
   */
  export type ViolenceSituationsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViolenceSituations
     */
    select?: ViolenceSituationsSelect<ExtArgs> | null
    /**
     * Filter, which ViolenceSituations to fetch.
     */
    where?: ViolenceSituationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViolenceSituations to fetch.
     */
    orderBy?: ViolenceSituationsOrderByWithRelationInput | ViolenceSituationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViolenceSituations.
     */
    cursor?: ViolenceSituationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViolenceSituations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViolenceSituations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViolenceSituations.
     */
    distinct?: ViolenceSituationsScalarFieldEnum | ViolenceSituationsScalarFieldEnum[]
  }

  /**
   * ViolenceSituations findFirstOrThrow
   */
  export type ViolenceSituationsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViolenceSituations
     */
    select?: ViolenceSituationsSelect<ExtArgs> | null
    /**
     * Filter, which ViolenceSituations to fetch.
     */
    where?: ViolenceSituationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViolenceSituations to fetch.
     */
    orderBy?: ViolenceSituationsOrderByWithRelationInput | ViolenceSituationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ViolenceSituations.
     */
    cursor?: ViolenceSituationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViolenceSituations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViolenceSituations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ViolenceSituations.
     */
    distinct?: ViolenceSituationsScalarFieldEnum | ViolenceSituationsScalarFieldEnum[]
  }

  /**
   * ViolenceSituations findMany
   */
  export type ViolenceSituationsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViolenceSituations
     */
    select?: ViolenceSituationsSelect<ExtArgs> | null
    /**
     * Filter, which ViolenceSituations to fetch.
     */
    where?: ViolenceSituationsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ViolenceSituations to fetch.
     */
    orderBy?: ViolenceSituationsOrderByWithRelationInput | ViolenceSituationsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ViolenceSituations.
     */
    cursor?: ViolenceSituationsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ViolenceSituations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ViolenceSituations.
     */
    skip?: number
    distinct?: ViolenceSituationsScalarFieldEnum | ViolenceSituationsScalarFieldEnum[]
  }

  /**
   * ViolenceSituations create
   */
  export type ViolenceSituationsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViolenceSituations
     */
    select?: ViolenceSituationsSelect<ExtArgs> | null
    /**
     * The data needed to create a ViolenceSituations.
     */
    data: XOR<ViolenceSituationsCreateInput, ViolenceSituationsUncheckedCreateInput>
  }

  /**
   * ViolenceSituations createMany
   */
  export type ViolenceSituationsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ViolenceSituations.
     */
    data: ViolenceSituationsCreateManyInput | ViolenceSituationsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ViolenceSituations update
   */
  export type ViolenceSituationsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViolenceSituations
     */
    select?: ViolenceSituationsSelect<ExtArgs> | null
    /**
     * The data needed to update a ViolenceSituations.
     */
    data: XOR<ViolenceSituationsUpdateInput, ViolenceSituationsUncheckedUpdateInput>
    /**
     * Choose, which ViolenceSituations to update.
     */
    where: ViolenceSituationsWhereUniqueInput
  }

  /**
   * ViolenceSituations updateMany
   */
  export type ViolenceSituationsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ViolenceSituations.
     */
    data: XOR<ViolenceSituationsUpdateManyMutationInput, ViolenceSituationsUncheckedUpdateManyInput>
    /**
     * Filter which ViolenceSituations to update
     */
    where?: ViolenceSituationsWhereInput
  }

  /**
   * ViolenceSituations upsert
   */
  export type ViolenceSituationsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViolenceSituations
     */
    select?: ViolenceSituationsSelect<ExtArgs> | null
    /**
     * The filter to search for the ViolenceSituations to update in case it exists.
     */
    where: ViolenceSituationsWhereUniqueInput
    /**
     * In case the ViolenceSituations found by the `where` argument doesn't exist, create a new ViolenceSituations with this data.
     */
    create: XOR<ViolenceSituationsCreateInput, ViolenceSituationsUncheckedCreateInput>
    /**
     * In case the ViolenceSituations was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ViolenceSituationsUpdateInput, ViolenceSituationsUncheckedUpdateInput>
  }

  /**
   * ViolenceSituations delete
   */
  export type ViolenceSituationsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViolenceSituations
     */
    select?: ViolenceSituationsSelect<ExtArgs> | null
    /**
     * Filter which ViolenceSituations to delete.
     */
    where: ViolenceSituationsWhereUniqueInput
  }

  /**
   * ViolenceSituations deleteMany
   */
  export type ViolenceSituationsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ViolenceSituations to delete
     */
    where?: ViolenceSituationsWhereInput
  }

  /**
   * ViolenceSituations without action
   */
  export type ViolenceSituationsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ViolenceSituations
     */
    select?: ViolenceSituationsSelect<ExtArgs> | null
  }


  /**
   * Model StateList
   */

  export type AggregateStateList = {
    _count: StateListCountAggregateOutputType | null
    _avg: StateListAvgAggregateOutputType | null
    _sum: StateListSumAggregateOutputType | null
    _min: StateListMinAggregateOutputType | null
    _max: StateListMaxAggregateOutputType | null
  }

  export type StateListAvgAggregateOutputType = {
    id_State: number | null
    num_Occurrences: number | null
  }

  export type StateListSumAggregateOutputType = {
    id_State: bigint | null
    num_Occurrences: bigint | null
  }

  export type StateListMinAggregateOutputType = {
    id_State: bigint | null
    uf_State: string | null
    name_State: string | null
    num_Occurrences: bigint | null
  }

  export type StateListMaxAggregateOutputType = {
    id_State: bigint | null
    uf_State: string | null
    name_State: string | null
    num_Occurrences: bigint | null
  }

  export type StateListCountAggregateOutputType = {
    id_State: number
    uf_State: number
    name_State: number
    num_Occurrences: number
    _all: number
  }


  export type StateListAvgAggregateInputType = {
    id_State?: true
    num_Occurrences?: true
  }

  export type StateListSumAggregateInputType = {
    id_State?: true
    num_Occurrences?: true
  }

  export type StateListMinAggregateInputType = {
    id_State?: true
    uf_State?: true
    name_State?: true
    num_Occurrences?: true
  }

  export type StateListMaxAggregateInputType = {
    id_State?: true
    uf_State?: true
    name_State?: true
    num_Occurrences?: true
  }

  export type StateListCountAggregateInputType = {
    id_State?: true
    uf_State?: true
    name_State?: true
    num_Occurrences?: true
    _all?: true
  }

  export type StateListAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StateList to aggregate.
     */
    where?: StateListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StateLists to fetch.
     */
    orderBy?: StateListOrderByWithRelationInput | StateListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StateListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StateLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StateLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StateLists
    **/
    _count?: true | StateListCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: StateListAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: StateListSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StateListMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StateListMaxAggregateInputType
  }

  export type GetStateListAggregateType<T extends StateListAggregateArgs> = {
        [P in keyof T & keyof AggregateStateList]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStateList[P]>
      : GetScalarType<T[P], AggregateStateList[P]>
  }




  export type StateListGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StateListWhereInput
    orderBy?: StateListOrderByWithAggregationInput | StateListOrderByWithAggregationInput[]
    by: StateListScalarFieldEnum[] | StateListScalarFieldEnum
    having?: StateListScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StateListCountAggregateInputType | true
    _avg?: StateListAvgAggregateInputType
    _sum?: StateListSumAggregateInputType
    _min?: StateListMinAggregateInputType
    _max?: StateListMaxAggregateInputType
  }

  export type StateListGroupByOutputType = {
    id_State: bigint
    uf_State: string
    name_State: string
    num_Occurrences: bigint | null
    _count: StateListCountAggregateOutputType | null
    _avg: StateListAvgAggregateOutputType | null
    _sum: StateListSumAggregateOutputType | null
    _min: StateListMinAggregateOutputType | null
    _max: StateListMaxAggregateOutputType | null
  }

  type GetStateListGroupByPayload<T extends StateListGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StateListGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StateListGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StateListGroupByOutputType[P]>
            : GetScalarType<T[P], StateListGroupByOutputType[P]>
        }
      >
    >


  export type StateListSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id_State?: boolean
    uf_State?: boolean
    name_State?: boolean
    num_Occurrences?: boolean
    Occurrence?: boolean | StateList$OccurrenceArgs<ExtArgs>
    _count?: boolean | StateListCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["stateList"]>

  export type StateListSelectScalar = {
    id_State?: boolean
    uf_State?: boolean
    name_State?: boolean
    num_Occurrences?: boolean
  }


  export type StateListInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Occurrence?: boolean | StateList$OccurrenceArgs<ExtArgs>
    _count?: boolean | StateListCountOutputTypeDefaultArgs<ExtArgs>
  }


  export type $StateListPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StateList"
    objects: {
      Occurrence: Prisma.$OccurrencePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id_State: bigint
      uf_State: string
      name_State: string
      num_Occurrences: bigint | null
    }, ExtArgs["result"]["stateList"]>
    composites: {}
  }


  type StateListGetPayload<S extends boolean | null | undefined | StateListDefaultArgs> = $Result.GetResult<Prisma.$StateListPayload, S>

  type StateListCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<StateListFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: StateListCountAggregateInputType | true
    }

  export interface StateListDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StateList'], meta: { name: 'StateList' } }
    /**
     * Find zero or one StateList that matches the filter.
     * @param {StateListFindUniqueArgs} args - Arguments to find a StateList
     * @example
     * // Get one StateList
     * const stateList = await prisma.stateList.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends StateListFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, StateListFindUniqueArgs<ExtArgs>>
    ): Prisma__StateListClient<$Result.GetResult<Prisma.$StateListPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one StateList that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {StateListFindUniqueOrThrowArgs} args - Arguments to find a StateList
     * @example
     * // Get one StateList
     * const stateList = await prisma.stateList.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends StateListFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StateListFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__StateListClient<$Result.GetResult<Prisma.$StateListPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first StateList that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateListFindFirstArgs} args - Arguments to find a StateList
     * @example
     * // Get one StateList
     * const stateList = await prisma.stateList.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends StateListFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, StateListFindFirstArgs<ExtArgs>>
    ): Prisma__StateListClient<$Result.GetResult<Prisma.$StateListPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first StateList that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateListFindFirstOrThrowArgs} args - Arguments to find a StateList
     * @example
     * // Get one StateList
     * const stateList = await prisma.stateList.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends StateListFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, StateListFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__StateListClient<$Result.GetResult<Prisma.$StateListPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more StateLists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateListFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StateLists
     * const stateLists = await prisma.stateList.findMany()
     * 
     * // Get first 10 StateLists
     * const stateLists = await prisma.stateList.findMany({ take: 10 })
     * 
     * // Only select the `id_State`
     * const stateListWithId_StateOnly = await prisma.stateList.findMany({ select: { id_State: true } })
     * 
    **/
    findMany<T extends StateListFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StateListFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StateListPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a StateList.
     * @param {StateListCreateArgs} args - Arguments to create a StateList.
     * @example
     * // Create one StateList
     * const StateList = await prisma.stateList.create({
     *   data: {
     *     // ... data to create a StateList
     *   }
     * })
     * 
    **/
    create<T extends StateListCreateArgs<ExtArgs>>(
      args: SelectSubset<T, StateListCreateArgs<ExtArgs>>
    ): Prisma__StateListClient<$Result.GetResult<Prisma.$StateListPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many StateLists.
     * @param {StateListCreateManyArgs} args - Arguments to create many StateLists.
     * @example
     * // Create many StateLists
     * const stateList = await prisma.stateList.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends StateListCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StateListCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a StateList.
     * @param {StateListDeleteArgs} args - Arguments to delete one StateList.
     * @example
     * // Delete one StateList
     * const StateList = await prisma.stateList.delete({
     *   where: {
     *     // ... filter to delete one StateList
     *   }
     * })
     * 
    **/
    delete<T extends StateListDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, StateListDeleteArgs<ExtArgs>>
    ): Prisma__StateListClient<$Result.GetResult<Prisma.$StateListPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one StateList.
     * @param {StateListUpdateArgs} args - Arguments to update one StateList.
     * @example
     * // Update one StateList
     * const stateList = await prisma.stateList.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends StateListUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, StateListUpdateArgs<ExtArgs>>
    ): Prisma__StateListClient<$Result.GetResult<Prisma.$StateListPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more StateLists.
     * @param {StateListDeleteManyArgs} args - Arguments to filter StateLists to delete.
     * @example
     * // Delete a few StateLists
     * const { count } = await prisma.stateList.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends StateListDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, StateListDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StateLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateListUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StateLists
     * const stateList = await prisma.stateList.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends StateListUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, StateListUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one StateList.
     * @param {StateListUpsertArgs} args - Arguments to update or create a StateList.
     * @example
     * // Update or create a StateList
     * const stateList = await prisma.stateList.upsert({
     *   create: {
     *     // ... data to create a StateList
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StateList we want to update
     *   }
     * })
    **/
    upsert<T extends StateListUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, StateListUpsertArgs<ExtArgs>>
    ): Prisma__StateListClient<$Result.GetResult<Prisma.$StateListPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of StateLists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateListCountArgs} args - Arguments to filter StateLists to count.
     * @example
     * // Count the number of StateLists
     * const count = await prisma.stateList.count({
     *   where: {
     *     // ... the filter for the StateLists we want to count
     *   }
     * })
    **/
    count<T extends StateListCountArgs>(
      args?: Subset<T, StateListCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StateListCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StateList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateListAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StateListAggregateArgs>(args: Subset<T, StateListAggregateArgs>): Prisma.PrismaPromise<GetStateListAggregateType<T>>

    /**
     * Group by StateList.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StateListGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StateListGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StateListGroupByArgs['orderBy'] }
        : { orderBy?: StateListGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StateListGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStateListGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StateList model
   */
  readonly fields: StateListFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StateList.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StateListClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';

    Occurrence<T extends StateList$OccurrenceArgs<ExtArgs> = {}>(args?: Subset<T, StateList$OccurrenceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$OccurrencePayload<ExtArgs>, T, 'findMany'> | Null>;

    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the StateList model
   */ 
  interface StateListFieldRefs {
    readonly id_State: FieldRef<"StateList", 'BigInt'>
    readonly uf_State: FieldRef<"StateList", 'String'>
    readonly name_State: FieldRef<"StateList", 'String'>
    readonly num_Occurrences: FieldRef<"StateList", 'BigInt'>
  }
    

  // Custom InputTypes
  /**
   * StateList findUnique
   */
  export type StateListFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateList
     */
    select?: StateListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateListInclude<ExtArgs> | null
    /**
     * Filter, which StateList to fetch.
     */
    where: StateListWhereUniqueInput
  }

  /**
   * StateList findUniqueOrThrow
   */
  export type StateListFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateList
     */
    select?: StateListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateListInclude<ExtArgs> | null
    /**
     * Filter, which StateList to fetch.
     */
    where: StateListWhereUniqueInput
  }

  /**
   * StateList findFirst
   */
  export type StateListFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateList
     */
    select?: StateListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateListInclude<ExtArgs> | null
    /**
     * Filter, which StateList to fetch.
     */
    where?: StateListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StateLists to fetch.
     */
    orderBy?: StateListOrderByWithRelationInput | StateListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StateLists.
     */
    cursor?: StateListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StateLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StateLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StateLists.
     */
    distinct?: StateListScalarFieldEnum | StateListScalarFieldEnum[]
  }

  /**
   * StateList findFirstOrThrow
   */
  export type StateListFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateList
     */
    select?: StateListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateListInclude<ExtArgs> | null
    /**
     * Filter, which StateList to fetch.
     */
    where?: StateListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StateLists to fetch.
     */
    orderBy?: StateListOrderByWithRelationInput | StateListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StateLists.
     */
    cursor?: StateListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StateLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StateLists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StateLists.
     */
    distinct?: StateListScalarFieldEnum | StateListScalarFieldEnum[]
  }

  /**
   * StateList findMany
   */
  export type StateListFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateList
     */
    select?: StateListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateListInclude<ExtArgs> | null
    /**
     * Filter, which StateLists to fetch.
     */
    where?: StateListWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StateLists to fetch.
     */
    orderBy?: StateListOrderByWithRelationInput | StateListOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StateLists.
     */
    cursor?: StateListWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` StateLists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StateLists.
     */
    skip?: number
    distinct?: StateListScalarFieldEnum | StateListScalarFieldEnum[]
  }

  /**
   * StateList create
   */
  export type StateListCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateList
     */
    select?: StateListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateListInclude<ExtArgs> | null
    /**
     * The data needed to create a StateList.
     */
    data: XOR<StateListCreateInput, StateListUncheckedCreateInput>
  }

  /**
   * StateList createMany
   */
  export type StateListCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StateLists.
     */
    data: StateListCreateManyInput | StateListCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StateList update
   */
  export type StateListUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateList
     */
    select?: StateListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateListInclude<ExtArgs> | null
    /**
     * The data needed to update a StateList.
     */
    data: XOR<StateListUpdateInput, StateListUncheckedUpdateInput>
    /**
     * Choose, which StateList to update.
     */
    where: StateListWhereUniqueInput
  }

  /**
   * StateList updateMany
   */
  export type StateListUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StateLists.
     */
    data: XOR<StateListUpdateManyMutationInput, StateListUncheckedUpdateManyInput>
    /**
     * Filter which StateLists to update
     */
    where?: StateListWhereInput
  }

  /**
   * StateList upsert
   */
  export type StateListUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateList
     */
    select?: StateListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateListInclude<ExtArgs> | null
    /**
     * The filter to search for the StateList to update in case it exists.
     */
    where: StateListWhereUniqueInput
    /**
     * In case the StateList found by the `where` argument doesn't exist, create a new StateList with this data.
     */
    create: XOR<StateListCreateInput, StateListUncheckedCreateInput>
    /**
     * In case the StateList was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StateListUpdateInput, StateListUncheckedUpdateInput>
  }

  /**
   * StateList delete
   */
  export type StateListDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateList
     */
    select?: StateListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateListInclude<ExtArgs> | null
    /**
     * Filter which StateList to delete.
     */
    where: StateListWhereUniqueInput
  }

  /**
   * StateList deleteMany
   */
  export type StateListDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StateLists to delete
     */
    where?: StateListWhereInput
  }

  /**
   * StateList.Occurrence
   */
  export type StateList$OccurrenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Occurrence
     */
    select?: OccurrenceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: OccurrenceInclude<ExtArgs> | null
    where?: OccurrenceWhereInput
    orderBy?: OccurrenceOrderByWithRelationInput | OccurrenceOrderByWithRelationInput[]
    cursor?: OccurrenceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: OccurrenceScalarFieldEnum | OccurrenceScalarFieldEnum[]
  }

  /**
   * StateList without action
   */
  export type StateListDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StateList
     */
    select?: StateListSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StateListInclude<ExtArgs> | null
  }


  /**
   * Model Access
   */

  export type AggregateAccess = {
    _count: AccessCountAggregateOutputType | null
    _avg: AccessAvgAggregateOutputType | null
    _sum: AccessSumAggregateOutputType | null
    _min: AccessMinAggregateOutputType | null
    _max: AccessMaxAggregateOutputType | null
  }

  export type AccessAvgAggregateOutputType = {
    id: number | null
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type AccessSumAggregateOutputType = {
    id: number | null
    latitude: Decimal | null
    longitude: Decimal | null
  }

  export type AccessMinAggregateOutputType = {
    id: number | null
    fingerprint: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    createdAt: Date | null
  }

  export type AccessMaxAggregateOutputType = {
    id: number | null
    fingerprint: string | null
    latitude: Decimal | null
    longitude: Decimal | null
    createdAt: Date | null
  }

  export type AccessCountAggregateOutputType = {
    id: number
    fingerprint: number
    latitude: number
    longitude: number
    createdAt: number
    _all: number
  }


  export type AccessAvgAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
  }

  export type AccessSumAggregateInputType = {
    id?: true
    latitude?: true
    longitude?: true
  }

  export type AccessMinAggregateInputType = {
    id?: true
    fingerprint?: true
    latitude?: true
    longitude?: true
    createdAt?: true
  }

  export type AccessMaxAggregateInputType = {
    id?: true
    fingerprint?: true
    latitude?: true
    longitude?: true
    createdAt?: true
  }

  export type AccessCountAggregateInputType = {
    id?: true
    fingerprint?: true
    latitude?: true
    longitude?: true
    createdAt?: true
    _all?: true
  }

  export type AccessAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Access to aggregate.
     */
    where?: AccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accesses to fetch.
     */
    orderBy?: AccessOrderByWithRelationInput | AccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accesses
    **/
    _count?: true | AccessCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccessAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccessSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccessMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccessMaxAggregateInputType
  }

  export type GetAccessAggregateType<T extends AccessAggregateArgs> = {
        [P in keyof T & keyof AggregateAccess]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccess[P]>
      : GetScalarType<T[P], AggregateAccess[P]>
  }




  export type AccessGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccessWhereInput
    orderBy?: AccessOrderByWithAggregationInput | AccessOrderByWithAggregationInput[]
    by: AccessScalarFieldEnum[] | AccessScalarFieldEnum
    having?: AccessScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccessCountAggregateInputType | true
    _avg?: AccessAvgAggregateInputType
    _sum?: AccessSumAggregateInputType
    _min?: AccessMinAggregateInputType
    _max?: AccessMaxAggregateInputType
  }

  export type AccessGroupByOutputType = {
    id: number
    fingerprint: string
    latitude: Decimal
    longitude: Decimal
    createdAt: Date
    _count: AccessCountAggregateOutputType | null
    _avg: AccessAvgAggregateOutputType | null
    _sum: AccessSumAggregateOutputType | null
    _min: AccessMinAggregateOutputType | null
    _max: AccessMaxAggregateOutputType | null
  }

  type GetAccessGroupByPayload<T extends AccessGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccessGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccessGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccessGroupByOutputType[P]>
            : GetScalarType<T[P], AccessGroupByOutputType[P]>
        }
      >
    >


  export type AccessSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fingerprint?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
  }, ExtArgs["result"]["access"]>

  export type AccessSelectScalar = {
    id?: boolean
    fingerprint?: boolean
    latitude?: boolean
    longitude?: boolean
    createdAt?: boolean
  }



  export type $AccessPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Access"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: number
      fingerprint: string
      latitude: Prisma.Decimal
      longitude: Prisma.Decimal
      createdAt: Date
    }, ExtArgs["result"]["access"]>
    composites: {}
  }


  type AccessGetPayload<S extends boolean | null | undefined | AccessDefaultArgs> = $Result.GetResult<Prisma.$AccessPayload, S>

  type AccessCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AccessFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AccessCountAggregateInputType | true
    }

  export interface AccessDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Access'], meta: { name: 'Access' } }
    /**
     * Find zero or one Access that matches the filter.
     * @param {AccessFindUniqueArgs} args - Arguments to find a Access
     * @example
     * // Get one Access
     * const access = await prisma.access.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUnique<T extends AccessFindUniqueArgs<ExtArgs>>(
      args: SelectSubset<T, AccessFindUniqueArgs<ExtArgs>>
    ): Prisma__AccessClient<$Result.GetResult<Prisma.$AccessPayload<ExtArgs>, T, 'findUnique'> | null, null, ExtArgs>

    /**
     * Find one Access that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AccessFindUniqueOrThrowArgs} args - Arguments to find a Access
     * @example
     * // Get one Access
     * const access = await prisma.access.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findUniqueOrThrow<T extends AccessFindUniqueOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccessFindUniqueOrThrowArgs<ExtArgs>>
    ): Prisma__AccessClient<$Result.GetResult<Prisma.$AccessPayload<ExtArgs>, T, 'findUniqueOrThrow'>, never, ExtArgs>

    /**
     * Find the first Access that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessFindFirstArgs} args - Arguments to find a Access
     * @example
     * // Get one Access
     * const access = await prisma.access.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirst<T extends AccessFindFirstArgs<ExtArgs>>(
      args?: SelectSubset<T, AccessFindFirstArgs<ExtArgs>>
    ): Prisma__AccessClient<$Result.GetResult<Prisma.$AccessPayload<ExtArgs>, T, 'findFirst'> | null, null, ExtArgs>

    /**
     * Find the first Access that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessFindFirstOrThrowArgs} args - Arguments to find a Access
     * @example
     * // Get one Access
     * const access = await prisma.access.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
    **/
    findFirstOrThrow<T extends AccessFindFirstOrThrowArgs<ExtArgs>>(
      args?: SelectSubset<T, AccessFindFirstOrThrowArgs<ExtArgs>>
    ): Prisma__AccessClient<$Result.GetResult<Prisma.$AccessPayload<ExtArgs>, T, 'findFirstOrThrow'>, never, ExtArgs>

    /**
     * Find zero or more Accesses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accesses
     * const accesses = await prisma.access.findMany()
     * 
     * // Get first 10 Accesses
     * const accesses = await prisma.access.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accessWithIdOnly = await prisma.access.findMany({ select: { id: true } })
     * 
    **/
    findMany<T extends AccessFindManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccessFindManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccessPayload<ExtArgs>, T, 'findMany'>>

    /**
     * Create a Access.
     * @param {AccessCreateArgs} args - Arguments to create a Access.
     * @example
     * // Create one Access
     * const Access = await prisma.access.create({
     *   data: {
     *     // ... data to create a Access
     *   }
     * })
     * 
    **/
    create<T extends AccessCreateArgs<ExtArgs>>(
      args: SelectSubset<T, AccessCreateArgs<ExtArgs>>
    ): Prisma__AccessClient<$Result.GetResult<Prisma.$AccessPayload<ExtArgs>, T, 'create'>, never, ExtArgs>

    /**
     * Create many Accesses.
     * @param {AccessCreateManyArgs} args - Arguments to create many Accesses.
     * @example
     * // Create many Accesses
     * const access = await prisma.access.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
    **/
    createMany<T extends AccessCreateManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccessCreateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Access.
     * @param {AccessDeleteArgs} args - Arguments to delete one Access.
     * @example
     * // Delete one Access
     * const Access = await prisma.access.delete({
     *   where: {
     *     // ... filter to delete one Access
     *   }
     * })
     * 
    **/
    delete<T extends AccessDeleteArgs<ExtArgs>>(
      args: SelectSubset<T, AccessDeleteArgs<ExtArgs>>
    ): Prisma__AccessClient<$Result.GetResult<Prisma.$AccessPayload<ExtArgs>, T, 'delete'>, never, ExtArgs>

    /**
     * Update one Access.
     * @param {AccessUpdateArgs} args - Arguments to update one Access.
     * @example
     * // Update one Access
     * const access = await prisma.access.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    update<T extends AccessUpdateArgs<ExtArgs>>(
      args: SelectSubset<T, AccessUpdateArgs<ExtArgs>>
    ): Prisma__AccessClient<$Result.GetResult<Prisma.$AccessPayload<ExtArgs>, T, 'update'>, never, ExtArgs>

    /**
     * Delete zero or more Accesses.
     * @param {AccessDeleteManyArgs} args - Arguments to filter Accesses to delete.
     * @example
     * // Delete a few Accesses
     * const { count } = await prisma.access.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
    **/
    deleteMany<T extends AccessDeleteManyArgs<ExtArgs>>(
      args?: SelectSubset<T, AccessDeleteManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accesses
     * const access = await prisma.access.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
    **/
    updateMany<T extends AccessUpdateManyArgs<ExtArgs>>(
      args: SelectSubset<T, AccessUpdateManyArgs<ExtArgs>>
    ): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Access.
     * @param {AccessUpsertArgs} args - Arguments to update or create a Access.
     * @example
     * // Update or create a Access
     * const access = await prisma.access.upsert({
     *   create: {
     *     // ... data to create a Access
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Access we want to update
     *   }
     * })
    **/
    upsert<T extends AccessUpsertArgs<ExtArgs>>(
      args: SelectSubset<T, AccessUpsertArgs<ExtArgs>>
    ): Prisma__AccessClient<$Result.GetResult<Prisma.$AccessPayload<ExtArgs>, T, 'upsert'>, never, ExtArgs>

    /**
     * Count the number of Accesses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessCountArgs} args - Arguments to filter Accesses to count.
     * @example
     * // Count the number of Accesses
     * const count = await prisma.access.count({
     *   where: {
     *     // ... the filter for the Accesses we want to count
     *   }
     * })
    **/
    count<T extends AccessCountArgs>(
      args?: Subset<T, AccessCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccessCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Access.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccessAggregateArgs>(args: Subset<T, AccessAggregateArgs>): Prisma.PrismaPromise<GetAccessAggregateType<T>>

    /**
     * Group by Access.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccessGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccessGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccessGroupByArgs['orderBy'] }
        : { orderBy?: AccessGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccessGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccessGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Access model
   */
  readonly fields: AccessFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Access.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccessClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: 'PrismaPromise';


    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>;
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>;
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>;
  }



  /**
   * Fields of the Access model
   */ 
  interface AccessFieldRefs {
    readonly id: FieldRef<"Access", 'Int'>
    readonly fingerprint: FieldRef<"Access", 'String'>
    readonly latitude: FieldRef<"Access", 'Decimal'>
    readonly longitude: FieldRef<"Access", 'Decimal'>
    readonly createdAt: FieldRef<"Access", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Access findUnique
   */
  export type AccessFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Access
     */
    select?: AccessSelect<ExtArgs> | null
    /**
     * Filter, which Access to fetch.
     */
    where: AccessWhereUniqueInput
  }

  /**
   * Access findUniqueOrThrow
   */
  export type AccessFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Access
     */
    select?: AccessSelect<ExtArgs> | null
    /**
     * Filter, which Access to fetch.
     */
    where: AccessWhereUniqueInput
  }

  /**
   * Access findFirst
   */
  export type AccessFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Access
     */
    select?: AccessSelect<ExtArgs> | null
    /**
     * Filter, which Access to fetch.
     */
    where?: AccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accesses to fetch.
     */
    orderBy?: AccessOrderByWithRelationInput | AccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accesses.
     */
    cursor?: AccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accesses.
     */
    distinct?: AccessScalarFieldEnum | AccessScalarFieldEnum[]
  }

  /**
   * Access findFirstOrThrow
   */
  export type AccessFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Access
     */
    select?: AccessSelect<ExtArgs> | null
    /**
     * Filter, which Access to fetch.
     */
    where?: AccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accesses to fetch.
     */
    orderBy?: AccessOrderByWithRelationInput | AccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accesses.
     */
    cursor?: AccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accesses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accesses.
     */
    distinct?: AccessScalarFieldEnum | AccessScalarFieldEnum[]
  }

  /**
   * Access findMany
   */
  export type AccessFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Access
     */
    select?: AccessSelect<ExtArgs> | null
    /**
     * Filter, which Accesses to fetch.
     */
    where?: AccessWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accesses to fetch.
     */
    orderBy?: AccessOrderByWithRelationInput | AccessOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accesses.
     */
    cursor?: AccessWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Accesses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accesses.
     */
    skip?: number
    distinct?: AccessScalarFieldEnum | AccessScalarFieldEnum[]
  }

  /**
   * Access create
   */
  export type AccessCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Access
     */
    select?: AccessSelect<ExtArgs> | null
    /**
     * The data needed to create a Access.
     */
    data: XOR<AccessCreateInput, AccessUncheckedCreateInput>
  }

  /**
   * Access createMany
   */
  export type AccessCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accesses.
     */
    data: AccessCreateManyInput | AccessCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Access update
   */
  export type AccessUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Access
     */
    select?: AccessSelect<ExtArgs> | null
    /**
     * The data needed to update a Access.
     */
    data: XOR<AccessUpdateInput, AccessUncheckedUpdateInput>
    /**
     * Choose, which Access to update.
     */
    where: AccessWhereUniqueInput
  }

  /**
   * Access updateMany
   */
  export type AccessUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accesses.
     */
    data: XOR<AccessUpdateManyMutationInput, AccessUncheckedUpdateManyInput>
    /**
     * Filter which Accesses to update
     */
    where?: AccessWhereInput
  }

  /**
   * Access upsert
   */
  export type AccessUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Access
     */
    select?: AccessSelect<ExtArgs> | null
    /**
     * The filter to search for the Access to update in case it exists.
     */
    where: AccessWhereUniqueInput
    /**
     * In case the Access found by the `where` argument doesn't exist, create a new Access with this data.
     */
    create: XOR<AccessCreateInput, AccessUncheckedCreateInput>
    /**
     * In case the Access was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccessUpdateInput, AccessUncheckedUpdateInput>
  }

  /**
   * Access delete
   */
  export type AccessDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Access
     */
    select?: AccessSelect<ExtArgs> | null
    /**
     * Filter which Access to delete.
     */
    where: AccessWhereUniqueInput
  }

  /**
   * Access deleteMany
   */
  export type AccessDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accesses to delete
     */
    where?: AccessWhereInput
  }

  /**
   * Access without action
   */
  export type AccessDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Access
     */
    select?: AccessSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const OccurrenceScalarFieldEnum: {
    id_occurrence: 'id_occurrence',
    id_user: 'id_user',
    datetime_submission: 'datetime_submission',
    State_violence: 'State_violence',
    date_violence: 'date_violence',
    time_violence: 'time_violence',
    agegroup: 'agegroup',
    latitude: 'latitude',
    longitude: 'longitude',
    violencesoptions: 'violencesoptions',
    violencetype: 'violencetype'
  };

  export type OccurrenceScalarFieldEnum = (typeof OccurrenceScalarFieldEnum)[keyof typeof OccurrenceScalarFieldEnum]


  export const TypesOfViolenceScalarFieldEnum: {
    id_violencetype: 'id_violencetype',
    Description: 'Description'
  };

  export type TypesOfViolenceScalarFieldEnum = (typeof TypesOfViolenceScalarFieldEnum)[keyof typeof TypesOfViolenceScalarFieldEnum]


  export const UserScalarFieldEnum: {
    id_user: 'id_user'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserIPScalarFieldEnum: {
    id: 'id',
    ip: 'ip',
    data: 'data'
  };

  export type UserIPScalarFieldEnum = (typeof UserIPScalarFieldEnum)[keyof typeof UserIPScalarFieldEnum]


  export const UserOccurrencesScalarFieldEnum: {
    id_occurrence: 'id_occurrence',
    id_user: 'id_user',
    date_violence: 'date_violence'
  };

  export type UserOccurrencesScalarFieldEnum = (typeof UserOccurrencesScalarFieldEnum)[keyof typeof UserOccurrencesScalarFieldEnum]


  export const ViolenceSituationsScalarFieldEnum: {
    id_violenceoption: 'id_violenceoption',
    Description: 'Description'
  };

  export type ViolenceSituationsScalarFieldEnum = (typeof ViolenceSituationsScalarFieldEnum)[keyof typeof ViolenceSituationsScalarFieldEnum]


  export const StateListScalarFieldEnum: {
    id_State: 'id_State',
    uf_State: 'uf_State',
    name_State: 'name_State',
    num_Occurrences: 'num_Occurrences'
  };

  export type StateListScalarFieldEnum = (typeof StateListScalarFieldEnum)[keyof typeof StateListScalarFieldEnum]


  export const AccessScalarFieldEnum: {
    id: 'id',
    fingerprint: 'fingerprint',
    latitude: 'latitude',
    longitude: 'longitude',
    createdAt: 'createdAt'
  };

  export type AccessScalarFieldEnum = (typeof AccessScalarFieldEnum)[keyof typeof AccessScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type OccurrenceWhereInput = {
    AND?: OccurrenceWhereInput | OccurrenceWhereInput[]
    OR?: OccurrenceWhereInput[]
    NOT?: OccurrenceWhereInput | OccurrenceWhereInput[]
    id_occurrence?: BigIntFilter<"Occurrence"> | bigint | number
    id_user?: BigIntFilter<"Occurrence"> | bigint | number
    datetime_submission?: DateTimeFilter<"Occurrence"> | Date | string
    State_violence?: StringNullableFilter<"Occurrence"> | string | null
    date_violence?: DateTimeNullableFilter<"Occurrence"> | Date | string | null
    time_violence?: DateTimeNullableFilter<"Occurrence"> | Date | string | null
    agegroup?: StringNullableFilter<"Occurrence"> | string | null
    latitude?: DecimalNullableFilter<"Occurrence"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Occurrence"> | Decimal | DecimalJsLike | number | string | null
    violencesoptions?: StringNullableFilter<"Occurrence"> | string | null
    violencetype?: StringNullableFilter<"Occurrence"> | string | null
    User?: XOR<UserIPRelationFilter, UserIPWhereInput>
    StateList?: XOR<StateListNullableRelationFilter, StateListWhereInput> | null
    UserOccurrences?: XOR<UserOccurrencesNullableRelationFilter, UserOccurrencesWhereInput> | null
  }

  export type OccurrenceOrderByWithRelationInput = {
    id_occurrence?: SortOrder
    id_user?: SortOrder
    datetime_submission?: SortOrder
    State_violence?: SortOrderInput | SortOrder
    date_violence?: SortOrderInput | SortOrder
    time_violence?: SortOrderInput | SortOrder
    agegroup?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    violencesoptions?: SortOrderInput | SortOrder
    violencetype?: SortOrderInput | SortOrder
    User?: UserIPOrderByWithRelationInput
    StateList?: StateListOrderByWithRelationInput
    UserOccurrences?: UserOccurrencesOrderByWithRelationInput
  }

  export type OccurrenceWhereUniqueInput = Prisma.AtLeast<{
    id_occurrence?: bigint | number
    id_user?: bigint | number
    AND?: OccurrenceWhereInput | OccurrenceWhereInput[]
    OR?: OccurrenceWhereInput[]
    NOT?: OccurrenceWhereInput | OccurrenceWhereInput[]
    datetime_submission?: DateTimeFilter<"Occurrence"> | Date | string
    State_violence?: StringNullableFilter<"Occurrence"> | string | null
    date_violence?: DateTimeNullableFilter<"Occurrence"> | Date | string | null
    time_violence?: DateTimeNullableFilter<"Occurrence"> | Date | string | null
    agegroup?: StringNullableFilter<"Occurrence"> | string | null
    latitude?: DecimalNullableFilter<"Occurrence"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Occurrence"> | Decimal | DecimalJsLike | number | string | null
    violencesoptions?: StringNullableFilter<"Occurrence"> | string | null
    violencetype?: StringNullableFilter<"Occurrence"> | string | null
    User?: XOR<UserIPRelationFilter, UserIPWhereInput>
    StateList?: XOR<StateListNullableRelationFilter, StateListWhereInput> | null
    UserOccurrences?: XOR<UserOccurrencesNullableRelationFilter, UserOccurrencesWhereInput> | null
  }, "id_occurrence" | "id_user">

  export type OccurrenceOrderByWithAggregationInput = {
    id_occurrence?: SortOrder
    id_user?: SortOrder
    datetime_submission?: SortOrder
    State_violence?: SortOrderInput | SortOrder
    date_violence?: SortOrderInput | SortOrder
    time_violence?: SortOrderInput | SortOrder
    agegroup?: SortOrderInput | SortOrder
    latitude?: SortOrderInput | SortOrder
    longitude?: SortOrderInput | SortOrder
    violencesoptions?: SortOrderInput | SortOrder
    violencetype?: SortOrderInput | SortOrder
    _count?: OccurrenceCountOrderByAggregateInput
    _avg?: OccurrenceAvgOrderByAggregateInput
    _max?: OccurrenceMaxOrderByAggregateInput
    _min?: OccurrenceMinOrderByAggregateInput
    _sum?: OccurrenceSumOrderByAggregateInput
  }

  export type OccurrenceScalarWhereWithAggregatesInput = {
    AND?: OccurrenceScalarWhereWithAggregatesInput | OccurrenceScalarWhereWithAggregatesInput[]
    OR?: OccurrenceScalarWhereWithAggregatesInput[]
    NOT?: OccurrenceScalarWhereWithAggregatesInput | OccurrenceScalarWhereWithAggregatesInput[]
    id_occurrence?: BigIntWithAggregatesFilter<"Occurrence"> | bigint | number
    id_user?: BigIntWithAggregatesFilter<"Occurrence"> | bigint | number
    datetime_submission?: DateTimeWithAggregatesFilter<"Occurrence"> | Date | string
    State_violence?: StringNullableWithAggregatesFilter<"Occurrence"> | string | null
    date_violence?: DateTimeNullableWithAggregatesFilter<"Occurrence"> | Date | string | null
    time_violence?: DateTimeNullableWithAggregatesFilter<"Occurrence"> | Date | string | null
    agegroup?: StringNullableWithAggregatesFilter<"Occurrence"> | string | null
    latitude?: DecimalNullableWithAggregatesFilter<"Occurrence"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableWithAggregatesFilter<"Occurrence"> | Decimal | DecimalJsLike | number | string | null
    violencesoptions?: StringNullableWithAggregatesFilter<"Occurrence"> | string | null
    violencetype?: StringNullableWithAggregatesFilter<"Occurrence"> | string | null
  }

  export type TypesOfViolenceWhereInput = {
    AND?: TypesOfViolenceWhereInput | TypesOfViolenceWhereInput[]
    OR?: TypesOfViolenceWhereInput[]
    NOT?: TypesOfViolenceWhereInput | TypesOfViolenceWhereInput[]
    id_violencetype?: StringFilter<"TypesOfViolence"> | string
    Description?: StringFilter<"TypesOfViolence"> | string
  }

  export type TypesOfViolenceOrderByWithRelationInput = {
    id_violencetype?: SortOrder
    Description?: SortOrder
  }

  export type TypesOfViolenceWhereUniqueInput = Prisma.AtLeast<{
    id_violencetype?: string
    AND?: TypesOfViolenceWhereInput | TypesOfViolenceWhereInput[]
    OR?: TypesOfViolenceWhereInput[]
    NOT?: TypesOfViolenceWhereInput | TypesOfViolenceWhereInput[]
    Description?: StringFilter<"TypesOfViolence"> | string
  }, "id_violencetype">

  export type TypesOfViolenceOrderByWithAggregationInput = {
    id_violencetype?: SortOrder
    Description?: SortOrder
    _count?: TypesOfViolenceCountOrderByAggregateInput
    _max?: TypesOfViolenceMaxOrderByAggregateInput
    _min?: TypesOfViolenceMinOrderByAggregateInput
  }

  export type TypesOfViolenceScalarWhereWithAggregatesInput = {
    AND?: TypesOfViolenceScalarWhereWithAggregatesInput | TypesOfViolenceScalarWhereWithAggregatesInput[]
    OR?: TypesOfViolenceScalarWhereWithAggregatesInput[]
    NOT?: TypesOfViolenceScalarWhereWithAggregatesInput | TypesOfViolenceScalarWhereWithAggregatesInput[]
    id_violencetype?: StringWithAggregatesFilter<"TypesOfViolence"> | string
    Description?: StringWithAggregatesFilter<"TypesOfViolence"> | string
  }

  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id_user?: StringFilter<"User"> | string
  }

  export type UserOrderByWithRelationInput = {
    id_user?: SortOrder
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id_user?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
  }, "id_user">

  export type UserOrderByWithAggregationInput = {
    id_user?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id_user?: StringWithAggregatesFilter<"User"> | string
  }

  export type UserIPWhereInput = {
    AND?: UserIPWhereInput | UserIPWhereInput[]
    OR?: UserIPWhereInput[]
    NOT?: UserIPWhereInput | UserIPWhereInput[]
    id?: BigIntFilter<"UserIP"> | bigint | number
    ip?: StringFilter<"UserIP"> | string
    data?: DateTimeFilter<"UserIP"> | Date | string
    Occurrence?: OccurrenceListRelationFilter
    UserOccurrences?: UserOccurrencesListRelationFilter
  }

  export type UserIPOrderByWithRelationInput = {
    id?: SortOrder
    ip?: SortOrder
    data?: SortOrder
    Occurrence?: OccurrenceOrderByRelationAggregateInput
    UserOccurrences?: UserOccurrencesOrderByRelationAggregateInput
  }

  export type UserIPWhereUniqueInput = Prisma.AtLeast<{
    id?: bigint | number
    AND?: UserIPWhereInput | UserIPWhereInput[]
    OR?: UserIPWhereInput[]
    NOT?: UserIPWhereInput | UserIPWhereInput[]
    ip?: StringFilter<"UserIP"> | string
    data?: DateTimeFilter<"UserIP"> | Date | string
    Occurrence?: OccurrenceListRelationFilter
    UserOccurrences?: UserOccurrencesListRelationFilter
  }, "id">

  export type UserIPOrderByWithAggregationInput = {
    id?: SortOrder
    ip?: SortOrder
    data?: SortOrder
    _count?: UserIPCountOrderByAggregateInput
    _avg?: UserIPAvgOrderByAggregateInput
    _max?: UserIPMaxOrderByAggregateInput
    _min?: UserIPMinOrderByAggregateInput
    _sum?: UserIPSumOrderByAggregateInput
  }

  export type UserIPScalarWhereWithAggregatesInput = {
    AND?: UserIPScalarWhereWithAggregatesInput | UserIPScalarWhereWithAggregatesInput[]
    OR?: UserIPScalarWhereWithAggregatesInput[]
    NOT?: UserIPScalarWhereWithAggregatesInput | UserIPScalarWhereWithAggregatesInput[]
    id?: BigIntWithAggregatesFilter<"UserIP"> | bigint | number
    ip?: StringWithAggregatesFilter<"UserIP"> | string
    data?: DateTimeWithAggregatesFilter<"UserIP"> | Date | string
  }

  export type UserOccurrencesWhereInput = {
    AND?: UserOccurrencesWhereInput | UserOccurrencesWhereInput[]
    OR?: UserOccurrencesWhereInput[]
    NOT?: UserOccurrencesWhereInput | UserOccurrencesWhereInput[]
    id_occurrence?: BigIntFilter<"UserOccurrences"> | bigint | number
    id_user?: BigIntFilter<"UserOccurrences"> | bigint | number
    date_violence?: DateTimeFilter<"UserOccurrences"> | Date | string
    Occurrence?: XOR<OccurrenceRelationFilter, OccurrenceWhereInput>
    User?: XOR<UserIPRelationFilter, UserIPWhereInput>
  }

  export type UserOccurrencesOrderByWithRelationInput = {
    id_occurrence?: SortOrder
    id_user?: SortOrder
    date_violence?: SortOrder
    Occurrence?: OccurrenceOrderByWithRelationInput
    User?: UserIPOrderByWithRelationInput
  }

  export type UserOccurrencesWhereUniqueInput = Prisma.AtLeast<{
    id_occurrence?: bigint | number
    AND?: UserOccurrencesWhereInput | UserOccurrencesWhereInput[]
    OR?: UserOccurrencesWhereInput[]
    NOT?: UserOccurrencesWhereInput | UserOccurrencesWhereInput[]
    id_user?: BigIntFilter<"UserOccurrences"> | bigint | number
    date_violence?: DateTimeFilter<"UserOccurrences"> | Date | string
    Occurrence?: XOR<OccurrenceRelationFilter, OccurrenceWhereInput>
    User?: XOR<UserIPRelationFilter, UserIPWhereInput>
  }, "id_occurrence">

  export type UserOccurrencesOrderByWithAggregationInput = {
    id_occurrence?: SortOrder
    id_user?: SortOrder
    date_violence?: SortOrder
    _count?: UserOccurrencesCountOrderByAggregateInput
    _avg?: UserOccurrencesAvgOrderByAggregateInput
    _max?: UserOccurrencesMaxOrderByAggregateInput
    _min?: UserOccurrencesMinOrderByAggregateInput
    _sum?: UserOccurrencesSumOrderByAggregateInput
  }

  export type UserOccurrencesScalarWhereWithAggregatesInput = {
    AND?: UserOccurrencesScalarWhereWithAggregatesInput | UserOccurrencesScalarWhereWithAggregatesInput[]
    OR?: UserOccurrencesScalarWhereWithAggregatesInput[]
    NOT?: UserOccurrencesScalarWhereWithAggregatesInput | UserOccurrencesScalarWhereWithAggregatesInput[]
    id_occurrence?: BigIntWithAggregatesFilter<"UserOccurrences"> | bigint | number
    id_user?: BigIntWithAggregatesFilter<"UserOccurrences"> | bigint | number
    date_violence?: DateTimeWithAggregatesFilter<"UserOccurrences"> | Date | string
  }

  export type ViolenceSituationsWhereInput = {
    AND?: ViolenceSituationsWhereInput | ViolenceSituationsWhereInput[]
    OR?: ViolenceSituationsWhereInput[]
    NOT?: ViolenceSituationsWhereInput | ViolenceSituationsWhereInput[]
    id_violenceoption?: StringFilter<"ViolenceSituations"> | string
    Description?: StringFilter<"ViolenceSituations"> | string
  }

  export type ViolenceSituationsOrderByWithRelationInput = {
    id_violenceoption?: SortOrder
    Description?: SortOrder
  }

  export type ViolenceSituationsWhereUniqueInput = Prisma.AtLeast<{
    id_violenceoption?: string
    AND?: ViolenceSituationsWhereInput | ViolenceSituationsWhereInput[]
    OR?: ViolenceSituationsWhereInput[]
    NOT?: ViolenceSituationsWhereInput | ViolenceSituationsWhereInput[]
    Description?: StringFilter<"ViolenceSituations"> | string
  }, "id_violenceoption">

  export type ViolenceSituationsOrderByWithAggregationInput = {
    id_violenceoption?: SortOrder
    Description?: SortOrder
    _count?: ViolenceSituationsCountOrderByAggregateInput
    _max?: ViolenceSituationsMaxOrderByAggregateInput
    _min?: ViolenceSituationsMinOrderByAggregateInput
  }

  export type ViolenceSituationsScalarWhereWithAggregatesInput = {
    AND?: ViolenceSituationsScalarWhereWithAggregatesInput | ViolenceSituationsScalarWhereWithAggregatesInput[]
    OR?: ViolenceSituationsScalarWhereWithAggregatesInput[]
    NOT?: ViolenceSituationsScalarWhereWithAggregatesInput | ViolenceSituationsScalarWhereWithAggregatesInput[]
    id_violenceoption?: StringWithAggregatesFilter<"ViolenceSituations"> | string
    Description?: StringWithAggregatesFilter<"ViolenceSituations"> | string
  }

  export type StateListWhereInput = {
    AND?: StateListWhereInput | StateListWhereInput[]
    OR?: StateListWhereInput[]
    NOT?: StateListWhereInput | StateListWhereInput[]
    id_State?: BigIntFilter<"StateList"> | bigint | number
    uf_State?: StringFilter<"StateList"> | string
    name_State?: StringFilter<"StateList"> | string
    num_Occurrences?: BigIntNullableFilter<"StateList"> | bigint | number | null
    Occurrence?: OccurrenceListRelationFilter
  }

  export type StateListOrderByWithRelationInput = {
    id_State?: SortOrder
    uf_State?: SortOrder
    name_State?: SortOrder
    num_Occurrences?: SortOrderInput | SortOrder
    Occurrence?: OccurrenceOrderByRelationAggregateInput
  }

  export type StateListWhereUniqueInput = Prisma.AtLeast<{
    id_State?: bigint | number
    uf_State?: string
    AND?: StateListWhereInput | StateListWhereInput[]
    OR?: StateListWhereInput[]
    NOT?: StateListWhereInput | StateListWhereInput[]
    name_State?: StringFilter<"StateList"> | string
    num_Occurrences?: BigIntNullableFilter<"StateList"> | bigint | number | null
    Occurrence?: OccurrenceListRelationFilter
  }, "id_State" | "uf_State">

  export type StateListOrderByWithAggregationInput = {
    id_State?: SortOrder
    uf_State?: SortOrder
    name_State?: SortOrder
    num_Occurrences?: SortOrderInput | SortOrder
    _count?: StateListCountOrderByAggregateInput
    _avg?: StateListAvgOrderByAggregateInput
    _max?: StateListMaxOrderByAggregateInput
    _min?: StateListMinOrderByAggregateInput
    _sum?: StateListSumOrderByAggregateInput
  }

  export type StateListScalarWhereWithAggregatesInput = {
    AND?: StateListScalarWhereWithAggregatesInput | StateListScalarWhereWithAggregatesInput[]
    OR?: StateListScalarWhereWithAggregatesInput[]
    NOT?: StateListScalarWhereWithAggregatesInput | StateListScalarWhereWithAggregatesInput[]
    id_State?: BigIntWithAggregatesFilter<"StateList"> | bigint | number
    uf_State?: StringWithAggregatesFilter<"StateList"> | string
    name_State?: StringWithAggregatesFilter<"StateList"> | string
    num_Occurrences?: BigIntNullableWithAggregatesFilter<"StateList"> | bigint | number | null
  }

  export type AccessWhereInput = {
    AND?: AccessWhereInput | AccessWhereInput[]
    OR?: AccessWhereInput[]
    NOT?: AccessWhereInput | AccessWhereInput[]
    id?: IntFilter<"Access"> | number
    fingerprint?: StringFilter<"Access"> | string
    latitude?: DecimalFilter<"Access"> | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFilter<"Access"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Access"> | Date | string
  }

  export type AccessOrderByWithRelationInput = {
    id?: SortOrder
    fingerprint?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
  }

  export type AccessWhereUniqueInput = Prisma.AtLeast<{
    id?: number
    AND?: AccessWhereInput | AccessWhereInput[]
    OR?: AccessWhereInput[]
    NOT?: AccessWhereInput | AccessWhereInput[]
    fingerprint?: StringFilter<"Access"> | string
    latitude?: DecimalFilter<"Access"> | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFilter<"Access"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFilter<"Access"> | Date | string
  }, "id">

  export type AccessOrderByWithAggregationInput = {
    id?: SortOrder
    fingerprint?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
    _count?: AccessCountOrderByAggregateInput
    _avg?: AccessAvgOrderByAggregateInput
    _max?: AccessMaxOrderByAggregateInput
    _min?: AccessMinOrderByAggregateInput
    _sum?: AccessSumOrderByAggregateInput
  }

  export type AccessScalarWhereWithAggregatesInput = {
    AND?: AccessScalarWhereWithAggregatesInput | AccessScalarWhereWithAggregatesInput[]
    OR?: AccessScalarWhereWithAggregatesInput[]
    NOT?: AccessScalarWhereWithAggregatesInput | AccessScalarWhereWithAggregatesInput[]
    id?: IntWithAggregatesFilter<"Access"> | number
    fingerprint?: StringWithAggregatesFilter<"Access"> | string
    latitude?: DecimalWithAggregatesFilter<"Access"> | Decimal | DecimalJsLike | number | string
    longitude?: DecimalWithAggregatesFilter<"Access"> | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeWithAggregatesFilter<"Access"> | Date | string
  }

  export type OccurrenceCreateInput = {
    id_occurrence?: bigint | number
    datetime_submission: Date | string
    date_violence?: Date | string | null
    time_violence?: Date | string | null
    agegroup?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    violencesoptions?: string | null
    violencetype?: string | null
    User: UserIPCreateNestedOneWithoutOccurrenceInput
    StateList?: StateListCreateNestedOneWithoutOccurrenceInput
    UserOccurrences?: UserOccurrencesCreateNestedOneWithoutOccurrenceInput
  }

  export type OccurrenceUncheckedCreateInput = {
    id_occurrence?: bigint | number
    id_user: bigint | number
    datetime_submission: Date | string
    State_violence?: string | null
    date_violence?: Date | string | null
    time_violence?: Date | string | null
    agegroup?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    violencesoptions?: string | null
    violencetype?: string | null
    UserOccurrences?: UserOccurrencesUncheckedCreateNestedOneWithoutOccurrenceInput
  }

  export type OccurrenceUpdateInput = {
    id_occurrence?: BigIntFieldUpdateOperationsInput | bigint | number
    datetime_submission?: DateTimeFieldUpdateOperationsInput | Date | string
    date_violence?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time_violence?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agegroup?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    violencesoptions?: NullableStringFieldUpdateOperationsInput | string | null
    violencetype?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserIPUpdateOneRequiredWithoutOccurrenceNestedInput
    StateList?: StateListUpdateOneWithoutOccurrenceNestedInput
    UserOccurrences?: UserOccurrencesUpdateOneWithoutOccurrenceNestedInput
  }

  export type OccurrenceUncheckedUpdateInput = {
    id_occurrence?: BigIntFieldUpdateOperationsInput | bigint | number
    id_user?: BigIntFieldUpdateOperationsInput | bigint | number
    datetime_submission?: DateTimeFieldUpdateOperationsInput | Date | string
    State_violence?: NullableStringFieldUpdateOperationsInput | string | null
    date_violence?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time_violence?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agegroup?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    violencesoptions?: NullableStringFieldUpdateOperationsInput | string | null
    violencetype?: NullableStringFieldUpdateOperationsInput | string | null
    UserOccurrences?: UserOccurrencesUncheckedUpdateOneWithoutOccurrenceNestedInput
  }

  export type OccurrenceCreateManyInput = {
    id_occurrence?: bigint | number
    id_user: bigint | number
    datetime_submission: Date | string
    State_violence?: string | null
    date_violence?: Date | string | null
    time_violence?: Date | string | null
    agegroup?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    violencesoptions?: string | null
    violencetype?: string | null
  }

  export type OccurrenceUpdateManyMutationInput = {
    id_occurrence?: BigIntFieldUpdateOperationsInput | bigint | number
    datetime_submission?: DateTimeFieldUpdateOperationsInput | Date | string
    date_violence?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time_violence?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agegroup?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    violencesoptions?: NullableStringFieldUpdateOperationsInput | string | null
    violencetype?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type OccurrenceUncheckedUpdateManyInput = {
    id_occurrence?: BigIntFieldUpdateOperationsInput | bigint | number
    id_user?: BigIntFieldUpdateOperationsInput | bigint | number
    datetime_submission?: DateTimeFieldUpdateOperationsInput | Date | string
    State_violence?: NullableStringFieldUpdateOperationsInput | string | null
    date_violence?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time_violence?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agegroup?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    violencesoptions?: NullableStringFieldUpdateOperationsInput | string | null
    violencetype?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TypesOfViolenceCreateInput = {
    id_violencetype: string
    Description: string
  }

  export type TypesOfViolenceUncheckedCreateInput = {
    id_violencetype: string
    Description: string
  }

  export type TypesOfViolenceUpdateInput = {
    id_violencetype?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
  }

  export type TypesOfViolenceUncheckedUpdateInput = {
    id_violencetype?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
  }

  export type TypesOfViolenceCreateManyInput = {
    id_violencetype: string
    Description: string
  }

  export type TypesOfViolenceUpdateManyMutationInput = {
    id_violencetype?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
  }

  export type TypesOfViolenceUncheckedUpdateManyInput = {
    id_violencetype?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateInput = {
    id_user: string
  }

  export type UserUncheckedCreateInput = {
    id_user: string
  }

  export type UserUpdateInput = {
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateInput = {
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type UserCreateManyInput = {
    id_user: string
  }

  export type UserUpdateManyMutationInput = {
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type UserUncheckedUpdateManyInput = {
    id_user?: StringFieldUpdateOperationsInput | string
  }

  export type UserIPCreateInput = {
    id?: bigint | number
    ip: string
    data?: Date | string
    Occurrence?: OccurrenceCreateNestedManyWithoutUserInput
    UserOccurrences?: UserOccurrencesCreateNestedManyWithoutUserInput
  }

  export type UserIPUncheckedCreateInput = {
    id?: bigint | number
    ip: string
    data?: Date | string
    Occurrence?: OccurrenceUncheckedCreateNestedManyWithoutUserInput
    UserOccurrences?: UserOccurrencesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserIPUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ip?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    Occurrence?: OccurrenceUpdateManyWithoutUserNestedInput
    UserOccurrences?: UserOccurrencesUpdateManyWithoutUserNestedInput
  }

  export type UserIPUncheckedUpdateInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ip?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    Occurrence?: OccurrenceUncheckedUpdateManyWithoutUserNestedInput
    UserOccurrences?: UserOccurrencesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type UserIPCreateManyInput = {
    id?: bigint | number
    ip: string
    data?: Date | string
  }

  export type UserIPUpdateManyMutationInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ip?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserIPUncheckedUpdateManyInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ip?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOccurrencesCreateInput = {
    date_violence: Date | string
    Occurrence: OccurrenceCreateNestedOneWithoutUserOccurrencesInput
    User: UserIPCreateNestedOneWithoutUserOccurrencesInput
  }

  export type UserOccurrencesUncheckedCreateInput = {
    id_occurrence: bigint | number
    id_user: bigint | number
    date_violence: Date | string
  }

  export type UserOccurrencesUpdateInput = {
    date_violence?: DateTimeFieldUpdateOperationsInput | Date | string
    Occurrence?: OccurrenceUpdateOneRequiredWithoutUserOccurrencesNestedInput
    User?: UserIPUpdateOneRequiredWithoutUserOccurrencesNestedInput
  }

  export type UserOccurrencesUncheckedUpdateInput = {
    id_occurrence?: BigIntFieldUpdateOperationsInput | bigint | number
    id_user?: BigIntFieldUpdateOperationsInput | bigint | number
    date_violence?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOccurrencesCreateManyInput = {
    id_occurrence: bigint | number
    id_user: bigint | number
    date_violence: Date | string
  }

  export type UserOccurrencesUpdateManyMutationInput = {
    date_violence?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOccurrencesUncheckedUpdateManyInput = {
    id_occurrence?: BigIntFieldUpdateOperationsInput | bigint | number
    id_user?: BigIntFieldUpdateOperationsInput | bigint | number
    date_violence?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ViolenceSituationsCreateInput = {
    id_violenceoption: string
    Description: string
  }

  export type ViolenceSituationsUncheckedCreateInput = {
    id_violenceoption: string
    Description: string
  }

  export type ViolenceSituationsUpdateInput = {
    id_violenceoption?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
  }

  export type ViolenceSituationsUncheckedUpdateInput = {
    id_violenceoption?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
  }

  export type ViolenceSituationsCreateManyInput = {
    id_violenceoption: string
    Description: string
  }

  export type ViolenceSituationsUpdateManyMutationInput = {
    id_violenceoption?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
  }

  export type ViolenceSituationsUncheckedUpdateManyInput = {
    id_violenceoption?: StringFieldUpdateOperationsInput | string
    Description?: StringFieldUpdateOperationsInput | string
  }

  export type StateListCreateInput = {
    id_State?: bigint | number
    uf_State: string
    name_State: string
    num_Occurrences?: bigint | number | null
    Occurrence?: OccurrenceCreateNestedManyWithoutStateListInput
  }

  export type StateListUncheckedCreateInput = {
    id_State?: bigint | number
    uf_State: string
    name_State: string
    num_Occurrences?: bigint | number | null
    Occurrence?: OccurrenceUncheckedCreateNestedManyWithoutStateListInput
  }

  export type StateListUpdateInput = {
    id_State?: BigIntFieldUpdateOperationsInput | bigint | number
    uf_State?: StringFieldUpdateOperationsInput | string
    name_State?: StringFieldUpdateOperationsInput | string
    num_Occurrences?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    Occurrence?: OccurrenceUpdateManyWithoutStateListNestedInput
  }

  export type StateListUncheckedUpdateInput = {
    id_State?: BigIntFieldUpdateOperationsInput | bigint | number
    uf_State?: StringFieldUpdateOperationsInput | string
    name_State?: StringFieldUpdateOperationsInput | string
    num_Occurrences?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
    Occurrence?: OccurrenceUncheckedUpdateManyWithoutStateListNestedInput
  }

  export type StateListCreateManyInput = {
    id_State?: bigint | number
    uf_State: string
    name_State: string
    num_Occurrences?: bigint | number | null
  }

  export type StateListUpdateManyMutationInput = {
    id_State?: BigIntFieldUpdateOperationsInput | bigint | number
    uf_State?: StringFieldUpdateOperationsInput | string
    name_State?: StringFieldUpdateOperationsInput | string
    num_Occurrences?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type StateListUncheckedUpdateManyInput = {
    id_State?: BigIntFieldUpdateOperationsInput | bigint | number
    uf_State?: StringFieldUpdateOperationsInput | string
    name_State?: StringFieldUpdateOperationsInput | string
    num_Occurrences?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type AccessCreateInput = {
    fingerprint: string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type AccessUncheckedCreateInput = {
    id?: number
    fingerprint: string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type AccessUpdateInput = {
    fingerprint?: StringFieldUpdateOperationsInput | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessUncheckedUpdateInput = {
    id?: IntFieldUpdateOperationsInput | number
    fingerprint?: StringFieldUpdateOperationsInput | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessCreateManyInput = {
    id?: number
    fingerprint: string
    latitude: Decimal | DecimalJsLike | number | string
    longitude: Decimal | DecimalJsLike | number | string
    createdAt?: Date | string
  }

  export type AccessUpdateManyMutationInput = {
    fingerprint?: StringFieldUpdateOperationsInput | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccessUncheckedUpdateManyInput = {
    id?: IntFieldUpdateOperationsInput | number
    fingerprint?: StringFieldUpdateOperationsInput | string
    latitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    longitude?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type UserIPRelationFilter = {
    is?: UserIPWhereInput
    isNot?: UserIPWhereInput
  }

  export type StateListNullableRelationFilter = {
    is?: StateListWhereInput | null
    isNot?: StateListWhereInput | null
  }

  export type UserOccurrencesNullableRelationFilter = {
    is?: UserOccurrencesWhereInput | null
    isNot?: UserOccurrencesWhereInput | null
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type OccurrenceCountOrderByAggregateInput = {
    id_occurrence?: SortOrder
    id_user?: SortOrder
    datetime_submission?: SortOrder
    State_violence?: SortOrder
    date_violence?: SortOrder
    time_violence?: SortOrder
    agegroup?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    violencesoptions?: SortOrder
    violencetype?: SortOrder
  }

  export type OccurrenceAvgOrderByAggregateInput = {
    id_occurrence?: SortOrder
    id_user?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type OccurrenceMaxOrderByAggregateInput = {
    id_occurrence?: SortOrder
    id_user?: SortOrder
    datetime_submission?: SortOrder
    State_violence?: SortOrder
    date_violence?: SortOrder
    time_violence?: SortOrder
    agegroup?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    violencesoptions?: SortOrder
    violencetype?: SortOrder
  }

  export type OccurrenceMinOrderByAggregateInput = {
    id_occurrence?: SortOrder
    id_user?: SortOrder
    datetime_submission?: SortOrder
    State_violence?: SortOrder
    date_violence?: SortOrder
    time_violence?: SortOrder
    agegroup?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    violencesoptions?: SortOrder
    violencetype?: SortOrder
  }

  export type OccurrenceSumOrderByAggregateInput = {
    id_occurrence?: SortOrder
    id_user?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type TypesOfViolenceCountOrderByAggregateInput = {
    id_violencetype?: SortOrder
    Description?: SortOrder
  }

  export type TypesOfViolenceMaxOrderByAggregateInput = {
    id_violencetype?: SortOrder
    Description?: SortOrder
  }

  export type TypesOfViolenceMinOrderByAggregateInput = {
    id_violencetype?: SortOrder
    Description?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type UserCountOrderByAggregateInput = {
    id_user?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id_user?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id_user?: SortOrder
  }

  export type OccurrenceListRelationFilter = {
    every?: OccurrenceWhereInput
    some?: OccurrenceWhereInput
    none?: OccurrenceWhereInput
  }

  export type UserOccurrencesListRelationFilter = {
    every?: UserOccurrencesWhereInput
    some?: UserOccurrencesWhereInput
    none?: UserOccurrencesWhereInput
  }

  export type OccurrenceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserOccurrencesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserIPCountOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    data?: SortOrder
  }

  export type UserIPAvgOrderByAggregateInput = {
    id?: SortOrder
  }

  export type UserIPMaxOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    data?: SortOrder
  }

  export type UserIPMinOrderByAggregateInput = {
    id?: SortOrder
    ip?: SortOrder
    data?: SortOrder
  }

  export type UserIPSumOrderByAggregateInput = {
    id?: SortOrder
  }

  export type OccurrenceRelationFilter = {
    is?: OccurrenceWhereInput
    isNot?: OccurrenceWhereInput
  }

  export type UserOccurrencesCountOrderByAggregateInput = {
    id_occurrence?: SortOrder
    id_user?: SortOrder
    date_violence?: SortOrder
  }

  export type UserOccurrencesAvgOrderByAggregateInput = {
    id_occurrence?: SortOrder
    id_user?: SortOrder
  }

  export type UserOccurrencesMaxOrderByAggregateInput = {
    id_occurrence?: SortOrder
    id_user?: SortOrder
    date_violence?: SortOrder
  }

  export type UserOccurrencesMinOrderByAggregateInput = {
    id_occurrence?: SortOrder
    id_user?: SortOrder
    date_violence?: SortOrder
  }

  export type UserOccurrencesSumOrderByAggregateInput = {
    id_occurrence?: SortOrder
    id_user?: SortOrder
  }

  export type ViolenceSituationsCountOrderByAggregateInput = {
    id_violenceoption?: SortOrder
    Description?: SortOrder
  }

  export type ViolenceSituationsMaxOrderByAggregateInput = {
    id_violenceoption?: SortOrder
    Description?: SortOrder
  }

  export type ViolenceSituationsMinOrderByAggregateInput = {
    id_violenceoption?: SortOrder
    Description?: SortOrder
  }

  export type BigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type StateListCountOrderByAggregateInput = {
    id_State?: SortOrder
    uf_State?: SortOrder
    name_State?: SortOrder
    num_Occurrences?: SortOrder
  }

  export type StateListAvgOrderByAggregateInput = {
    id_State?: SortOrder
    num_Occurrences?: SortOrder
  }

  export type StateListMaxOrderByAggregateInput = {
    id_State?: SortOrder
    uf_State?: SortOrder
    name_State?: SortOrder
    num_Occurrences?: SortOrder
  }

  export type StateListMinOrderByAggregateInput = {
    id_State?: SortOrder
    uf_State?: SortOrder
    name_State?: SortOrder
    num_Occurrences?: SortOrder
  }

  export type StateListSumOrderByAggregateInput = {
    id_State?: SortOrder
    num_Occurrences?: SortOrder
  }

  export type BigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type AccessCountOrderByAggregateInput = {
    id?: SortOrder
    fingerprint?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
  }

  export type AccessAvgOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type AccessMaxOrderByAggregateInput = {
    id?: SortOrder
    fingerprint?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
  }

  export type AccessMinOrderByAggregateInput = {
    id?: SortOrder
    fingerprint?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
    createdAt?: SortOrder
  }

  export type AccessSumOrderByAggregateInput = {
    id?: SortOrder
    latitude?: SortOrder
    longitude?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type UserIPCreateNestedOneWithoutOccurrenceInput = {
    create?: XOR<UserIPCreateWithoutOccurrenceInput, UserIPUncheckedCreateWithoutOccurrenceInput>
    connectOrCreate?: UserIPCreateOrConnectWithoutOccurrenceInput
    connect?: UserIPWhereUniqueInput
  }

  export type StateListCreateNestedOneWithoutOccurrenceInput = {
    create?: XOR<StateListCreateWithoutOccurrenceInput, StateListUncheckedCreateWithoutOccurrenceInput>
    connectOrCreate?: StateListCreateOrConnectWithoutOccurrenceInput
    connect?: StateListWhereUniqueInput
  }

  export type UserOccurrencesCreateNestedOneWithoutOccurrenceInput = {
    create?: XOR<UserOccurrencesCreateWithoutOccurrenceInput, UserOccurrencesUncheckedCreateWithoutOccurrenceInput>
    connectOrCreate?: UserOccurrencesCreateOrConnectWithoutOccurrenceInput
    connect?: UserOccurrencesWhereUniqueInput
  }

  export type UserOccurrencesUncheckedCreateNestedOneWithoutOccurrenceInput = {
    create?: XOR<UserOccurrencesCreateWithoutOccurrenceInput, UserOccurrencesUncheckedCreateWithoutOccurrenceInput>
    connectOrCreate?: UserOccurrencesCreateOrConnectWithoutOccurrenceInput
    connect?: UserOccurrencesWhereUniqueInput
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserIPUpdateOneRequiredWithoutOccurrenceNestedInput = {
    create?: XOR<UserIPCreateWithoutOccurrenceInput, UserIPUncheckedCreateWithoutOccurrenceInput>
    connectOrCreate?: UserIPCreateOrConnectWithoutOccurrenceInput
    upsert?: UserIPUpsertWithoutOccurrenceInput
    connect?: UserIPWhereUniqueInput
    update?: XOR<XOR<UserIPUpdateToOneWithWhereWithoutOccurrenceInput, UserIPUpdateWithoutOccurrenceInput>, UserIPUncheckedUpdateWithoutOccurrenceInput>
  }

  export type StateListUpdateOneWithoutOccurrenceNestedInput = {
    create?: XOR<StateListCreateWithoutOccurrenceInput, StateListUncheckedCreateWithoutOccurrenceInput>
    connectOrCreate?: StateListCreateOrConnectWithoutOccurrenceInput
    upsert?: StateListUpsertWithoutOccurrenceInput
    disconnect?: StateListWhereInput | boolean
    delete?: StateListWhereInput | boolean
    connect?: StateListWhereUniqueInput
    update?: XOR<XOR<StateListUpdateToOneWithWhereWithoutOccurrenceInput, StateListUpdateWithoutOccurrenceInput>, StateListUncheckedUpdateWithoutOccurrenceInput>
  }

  export type UserOccurrencesUpdateOneWithoutOccurrenceNestedInput = {
    create?: XOR<UserOccurrencesCreateWithoutOccurrenceInput, UserOccurrencesUncheckedCreateWithoutOccurrenceInput>
    connectOrCreate?: UserOccurrencesCreateOrConnectWithoutOccurrenceInput
    upsert?: UserOccurrencesUpsertWithoutOccurrenceInput
    disconnect?: UserOccurrencesWhereInput | boolean
    delete?: UserOccurrencesWhereInput | boolean
    connect?: UserOccurrencesWhereUniqueInput
    update?: XOR<XOR<UserOccurrencesUpdateToOneWithWhereWithoutOccurrenceInput, UserOccurrencesUpdateWithoutOccurrenceInput>, UserOccurrencesUncheckedUpdateWithoutOccurrenceInput>
  }

  export type UserOccurrencesUncheckedUpdateOneWithoutOccurrenceNestedInput = {
    create?: XOR<UserOccurrencesCreateWithoutOccurrenceInput, UserOccurrencesUncheckedCreateWithoutOccurrenceInput>
    connectOrCreate?: UserOccurrencesCreateOrConnectWithoutOccurrenceInput
    upsert?: UserOccurrencesUpsertWithoutOccurrenceInput
    disconnect?: UserOccurrencesWhereInput | boolean
    delete?: UserOccurrencesWhereInput | boolean
    connect?: UserOccurrencesWhereUniqueInput
    update?: XOR<XOR<UserOccurrencesUpdateToOneWithWhereWithoutOccurrenceInput, UserOccurrencesUpdateWithoutOccurrenceInput>, UserOccurrencesUncheckedUpdateWithoutOccurrenceInput>
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type OccurrenceCreateNestedManyWithoutUserInput = {
    create?: XOR<OccurrenceCreateWithoutUserInput, OccurrenceUncheckedCreateWithoutUserInput> | OccurrenceCreateWithoutUserInput[] | OccurrenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OccurrenceCreateOrConnectWithoutUserInput | OccurrenceCreateOrConnectWithoutUserInput[]
    createMany?: OccurrenceCreateManyUserInputEnvelope
    connect?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
  }

  export type UserOccurrencesCreateNestedManyWithoutUserInput = {
    create?: XOR<UserOccurrencesCreateWithoutUserInput, UserOccurrencesUncheckedCreateWithoutUserInput> | UserOccurrencesCreateWithoutUserInput[] | UserOccurrencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserOccurrencesCreateOrConnectWithoutUserInput | UserOccurrencesCreateOrConnectWithoutUserInput[]
    createMany?: UserOccurrencesCreateManyUserInputEnvelope
    connect?: UserOccurrencesWhereUniqueInput | UserOccurrencesWhereUniqueInput[]
  }

  export type OccurrenceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<OccurrenceCreateWithoutUserInput, OccurrenceUncheckedCreateWithoutUserInput> | OccurrenceCreateWithoutUserInput[] | OccurrenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OccurrenceCreateOrConnectWithoutUserInput | OccurrenceCreateOrConnectWithoutUserInput[]
    createMany?: OccurrenceCreateManyUserInputEnvelope
    connect?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
  }

  export type UserOccurrencesUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserOccurrencesCreateWithoutUserInput, UserOccurrencesUncheckedCreateWithoutUserInput> | UserOccurrencesCreateWithoutUserInput[] | UserOccurrencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserOccurrencesCreateOrConnectWithoutUserInput | UserOccurrencesCreateOrConnectWithoutUserInput[]
    createMany?: UserOccurrencesCreateManyUserInputEnvelope
    connect?: UserOccurrencesWhereUniqueInput | UserOccurrencesWhereUniqueInput[]
  }

  export type OccurrenceUpdateManyWithoutUserNestedInput = {
    create?: XOR<OccurrenceCreateWithoutUserInput, OccurrenceUncheckedCreateWithoutUserInput> | OccurrenceCreateWithoutUserInput[] | OccurrenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OccurrenceCreateOrConnectWithoutUserInput | OccurrenceCreateOrConnectWithoutUserInput[]
    upsert?: OccurrenceUpsertWithWhereUniqueWithoutUserInput | OccurrenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OccurrenceCreateManyUserInputEnvelope
    set?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
    disconnect?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
    delete?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
    connect?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
    update?: OccurrenceUpdateWithWhereUniqueWithoutUserInput | OccurrenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OccurrenceUpdateManyWithWhereWithoutUserInput | OccurrenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OccurrenceScalarWhereInput | OccurrenceScalarWhereInput[]
  }

  export type UserOccurrencesUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserOccurrencesCreateWithoutUserInput, UserOccurrencesUncheckedCreateWithoutUserInput> | UserOccurrencesCreateWithoutUserInput[] | UserOccurrencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserOccurrencesCreateOrConnectWithoutUserInput | UserOccurrencesCreateOrConnectWithoutUserInput[]
    upsert?: UserOccurrencesUpsertWithWhereUniqueWithoutUserInput | UserOccurrencesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserOccurrencesCreateManyUserInputEnvelope
    set?: UserOccurrencesWhereUniqueInput | UserOccurrencesWhereUniqueInput[]
    disconnect?: UserOccurrencesWhereUniqueInput | UserOccurrencesWhereUniqueInput[]
    delete?: UserOccurrencesWhereUniqueInput | UserOccurrencesWhereUniqueInput[]
    connect?: UserOccurrencesWhereUniqueInput | UserOccurrencesWhereUniqueInput[]
    update?: UserOccurrencesUpdateWithWhereUniqueWithoutUserInput | UserOccurrencesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserOccurrencesUpdateManyWithWhereWithoutUserInput | UserOccurrencesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserOccurrencesScalarWhereInput | UserOccurrencesScalarWhereInput[]
  }

  export type OccurrenceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<OccurrenceCreateWithoutUserInput, OccurrenceUncheckedCreateWithoutUserInput> | OccurrenceCreateWithoutUserInput[] | OccurrenceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: OccurrenceCreateOrConnectWithoutUserInput | OccurrenceCreateOrConnectWithoutUserInput[]
    upsert?: OccurrenceUpsertWithWhereUniqueWithoutUserInput | OccurrenceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: OccurrenceCreateManyUserInputEnvelope
    set?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
    disconnect?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
    delete?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
    connect?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
    update?: OccurrenceUpdateWithWhereUniqueWithoutUserInput | OccurrenceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: OccurrenceUpdateManyWithWhereWithoutUserInput | OccurrenceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: OccurrenceScalarWhereInput | OccurrenceScalarWhereInput[]
  }

  export type UserOccurrencesUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserOccurrencesCreateWithoutUserInput, UserOccurrencesUncheckedCreateWithoutUserInput> | UserOccurrencesCreateWithoutUserInput[] | UserOccurrencesUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserOccurrencesCreateOrConnectWithoutUserInput | UserOccurrencesCreateOrConnectWithoutUserInput[]
    upsert?: UserOccurrencesUpsertWithWhereUniqueWithoutUserInput | UserOccurrencesUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserOccurrencesCreateManyUserInputEnvelope
    set?: UserOccurrencesWhereUniqueInput | UserOccurrencesWhereUniqueInput[]
    disconnect?: UserOccurrencesWhereUniqueInput | UserOccurrencesWhereUniqueInput[]
    delete?: UserOccurrencesWhereUniqueInput | UserOccurrencesWhereUniqueInput[]
    connect?: UserOccurrencesWhereUniqueInput | UserOccurrencesWhereUniqueInput[]
    update?: UserOccurrencesUpdateWithWhereUniqueWithoutUserInput | UserOccurrencesUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserOccurrencesUpdateManyWithWhereWithoutUserInput | UserOccurrencesUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserOccurrencesScalarWhereInput | UserOccurrencesScalarWhereInput[]
  }

  export type OccurrenceCreateNestedOneWithoutUserOccurrencesInput = {
    create?: XOR<OccurrenceCreateWithoutUserOccurrencesInput, OccurrenceUncheckedCreateWithoutUserOccurrencesInput>
    connectOrCreate?: OccurrenceCreateOrConnectWithoutUserOccurrencesInput
    connect?: OccurrenceWhereUniqueInput
  }

  export type UserIPCreateNestedOneWithoutUserOccurrencesInput = {
    create?: XOR<UserIPCreateWithoutUserOccurrencesInput, UserIPUncheckedCreateWithoutUserOccurrencesInput>
    connectOrCreate?: UserIPCreateOrConnectWithoutUserOccurrencesInput
    connect?: UserIPWhereUniqueInput
  }

  export type OccurrenceUpdateOneRequiredWithoutUserOccurrencesNestedInput = {
    create?: XOR<OccurrenceCreateWithoutUserOccurrencesInput, OccurrenceUncheckedCreateWithoutUserOccurrencesInput>
    connectOrCreate?: OccurrenceCreateOrConnectWithoutUserOccurrencesInput
    upsert?: OccurrenceUpsertWithoutUserOccurrencesInput
    connect?: OccurrenceWhereUniqueInput
    update?: XOR<XOR<OccurrenceUpdateToOneWithWhereWithoutUserOccurrencesInput, OccurrenceUpdateWithoutUserOccurrencesInput>, OccurrenceUncheckedUpdateWithoutUserOccurrencesInput>
  }

  export type UserIPUpdateOneRequiredWithoutUserOccurrencesNestedInput = {
    create?: XOR<UserIPCreateWithoutUserOccurrencesInput, UserIPUncheckedCreateWithoutUserOccurrencesInput>
    connectOrCreate?: UserIPCreateOrConnectWithoutUserOccurrencesInput
    upsert?: UserIPUpsertWithoutUserOccurrencesInput
    connect?: UserIPWhereUniqueInput
    update?: XOR<XOR<UserIPUpdateToOneWithWhereWithoutUserOccurrencesInput, UserIPUpdateWithoutUserOccurrencesInput>, UserIPUncheckedUpdateWithoutUserOccurrencesInput>
  }

  export type OccurrenceCreateNestedManyWithoutStateListInput = {
    create?: XOR<OccurrenceCreateWithoutStateListInput, OccurrenceUncheckedCreateWithoutStateListInput> | OccurrenceCreateWithoutStateListInput[] | OccurrenceUncheckedCreateWithoutStateListInput[]
    connectOrCreate?: OccurrenceCreateOrConnectWithoutStateListInput | OccurrenceCreateOrConnectWithoutStateListInput[]
    createMany?: OccurrenceCreateManyStateListInputEnvelope
    connect?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
  }

  export type OccurrenceUncheckedCreateNestedManyWithoutStateListInput = {
    create?: XOR<OccurrenceCreateWithoutStateListInput, OccurrenceUncheckedCreateWithoutStateListInput> | OccurrenceCreateWithoutStateListInput[] | OccurrenceUncheckedCreateWithoutStateListInput[]
    connectOrCreate?: OccurrenceCreateOrConnectWithoutStateListInput | OccurrenceCreateOrConnectWithoutStateListInput[]
    createMany?: OccurrenceCreateManyStateListInputEnvelope
    connect?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
  }

  export type NullableBigIntFieldUpdateOperationsInput = {
    set?: bigint | number | null
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type OccurrenceUpdateManyWithoutStateListNestedInput = {
    create?: XOR<OccurrenceCreateWithoutStateListInput, OccurrenceUncheckedCreateWithoutStateListInput> | OccurrenceCreateWithoutStateListInput[] | OccurrenceUncheckedCreateWithoutStateListInput[]
    connectOrCreate?: OccurrenceCreateOrConnectWithoutStateListInput | OccurrenceCreateOrConnectWithoutStateListInput[]
    upsert?: OccurrenceUpsertWithWhereUniqueWithoutStateListInput | OccurrenceUpsertWithWhereUniqueWithoutStateListInput[]
    createMany?: OccurrenceCreateManyStateListInputEnvelope
    set?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
    disconnect?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
    delete?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
    connect?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
    update?: OccurrenceUpdateWithWhereUniqueWithoutStateListInput | OccurrenceUpdateWithWhereUniqueWithoutStateListInput[]
    updateMany?: OccurrenceUpdateManyWithWhereWithoutStateListInput | OccurrenceUpdateManyWithWhereWithoutStateListInput[]
    deleteMany?: OccurrenceScalarWhereInput | OccurrenceScalarWhereInput[]
  }

  export type OccurrenceUncheckedUpdateManyWithoutStateListNestedInput = {
    create?: XOR<OccurrenceCreateWithoutStateListInput, OccurrenceUncheckedCreateWithoutStateListInput> | OccurrenceCreateWithoutStateListInput[] | OccurrenceUncheckedCreateWithoutStateListInput[]
    connectOrCreate?: OccurrenceCreateOrConnectWithoutStateListInput | OccurrenceCreateOrConnectWithoutStateListInput[]
    upsert?: OccurrenceUpsertWithWhereUniqueWithoutStateListInput | OccurrenceUpsertWithWhereUniqueWithoutStateListInput[]
    createMany?: OccurrenceCreateManyStateListInputEnvelope
    set?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
    disconnect?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
    delete?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
    connect?: OccurrenceWhereUniqueInput | OccurrenceWhereUniqueInput[]
    update?: OccurrenceUpdateWithWhereUniqueWithoutStateListInput | OccurrenceUpdateWithWhereUniqueWithoutStateListInput[]
    updateMany?: OccurrenceUpdateManyWithWhereWithoutStateListInput | OccurrenceUpdateManyWithWhereWithoutStateListInput[]
    deleteMany?: OccurrenceScalarWhereInput | OccurrenceScalarWhereInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedBigIntNullableFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableFilter<$PrismaModel> | bigint | number | null
  }

  export type NestedBigIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel> | null
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel> | null
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntNullableWithAggregatesFilter<$PrismaModel> | bigint | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedBigIntNullableFilter<$PrismaModel>
    _min?: NestedBigIntNullableFilter<$PrismaModel>
    _max?: NestedBigIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type UserIPCreateWithoutOccurrenceInput = {
    id?: bigint | number
    ip: string
    data?: Date | string
    UserOccurrences?: UserOccurrencesCreateNestedManyWithoutUserInput
  }

  export type UserIPUncheckedCreateWithoutOccurrenceInput = {
    id?: bigint | number
    ip: string
    data?: Date | string
    UserOccurrences?: UserOccurrencesUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserIPCreateOrConnectWithoutOccurrenceInput = {
    where: UserIPWhereUniqueInput
    create: XOR<UserIPCreateWithoutOccurrenceInput, UserIPUncheckedCreateWithoutOccurrenceInput>
  }

  export type StateListCreateWithoutOccurrenceInput = {
    id_State?: bigint | number
    uf_State: string
    name_State: string
    num_Occurrences?: bigint | number | null
  }

  export type StateListUncheckedCreateWithoutOccurrenceInput = {
    id_State?: bigint | number
    uf_State: string
    name_State: string
    num_Occurrences?: bigint | number | null
  }

  export type StateListCreateOrConnectWithoutOccurrenceInput = {
    where: StateListWhereUniqueInput
    create: XOR<StateListCreateWithoutOccurrenceInput, StateListUncheckedCreateWithoutOccurrenceInput>
  }

  export type UserOccurrencesCreateWithoutOccurrenceInput = {
    date_violence: Date | string
    User: UserIPCreateNestedOneWithoutUserOccurrencesInput
  }

  export type UserOccurrencesUncheckedCreateWithoutOccurrenceInput = {
    id_user: bigint | number
    date_violence: Date | string
  }

  export type UserOccurrencesCreateOrConnectWithoutOccurrenceInput = {
    where: UserOccurrencesWhereUniqueInput
    create: XOR<UserOccurrencesCreateWithoutOccurrenceInput, UserOccurrencesUncheckedCreateWithoutOccurrenceInput>
  }

  export type UserIPUpsertWithoutOccurrenceInput = {
    update: XOR<UserIPUpdateWithoutOccurrenceInput, UserIPUncheckedUpdateWithoutOccurrenceInput>
    create: XOR<UserIPCreateWithoutOccurrenceInput, UserIPUncheckedCreateWithoutOccurrenceInput>
    where?: UserIPWhereInput
  }

  export type UserIPUpdateToOneWithWhereWithoutOccurrenceInput = {
    where?: UserIPWhereInput
    data: XOR<UserIPUpdateWithoutOccurrenceInput, UserIPUncheckedUpdateWithoutOccurrenceInput>
  }

  export type UserIPUpdateWithoutOccurrenceInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ip?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    UserOccurrences?: UserOccurrencesUpdateManyWithoutUserNestedInput
  }

  export type UserIPUncheckedUpdateWithoutOccurrenceInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ip?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    UserOccurrences?: UserOccurrencesUncheckedUpdateManyWithoutUserNestedInput
  }

  export type StateListUpsertWithoutOccurrenceInput = {
    update: XOR<StateListUpdateWithoutOccurrenceInput, StateListUncheckedUpdateWithoutOccurrenceInput>
    create: XOR<StateListCreateWithoutOccurrenceInput, StateListUncheckedCreateWithoutOccurrenceInput>
    where?: StateListWhereInput
  }

  export type StateListUpdateToOneWithWhereWithoutOccurrenceInput = {
    where?: StateListWhereInput
    data: XOR<StateListUpdateWithoutOccurrenceInput, StateListUncheckedUpdateWithoutOccurrenceInput>
  }

  export type StateListUpdateWithoutOccurrenceInput = {
    id_State?: BigIntFieldUpdateOperationsInput | bigint | number
    uf_State?: StringFieldUpdateOperationsInput | string
    name_State?: StringFieldUpdateOperationsInput | string
    num_Occurrences?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type StateListUncheckedUpdateWithoutOccurrenceInput = {
    id_State?: BigIntFieldUpdateOperationsInput | bigint | number
    uf_State?: StringFieldUpdateOperationsInput | string
    name_State?: StringFieldUpdateOperationsInput | string
    num_Occurrences?: NullableBigIntFieldUpdateOperationsInput | bigint | number | null
  }

  export type UserOccurrencesUpsertWithoutOccurrenceInput = {
    update: XOR<UserOccurrencesUpdateWithoutOccurrenceInput, UserOccurrencesUncheckedUpdateWithoutOccurrenceInput>
    create: XOR<UserOccurrencesCreateWithoutOccurrenceInput, UserOccurrencesUncheckedCreateWithoutOccurrenceInput>
    where?: UserOccurrencesWhereInput
  }

  export type UserOccurrencesUpdateToOneWithWhereWithoutOccurrenceInput = {
    where?: UserOccurrencesWhereInput
    data: XOR<UserOccurrencesUpdateWithoutOccurrenceInput, UserOccurrencesUncheckedUpdateWithoutOccurrenceInput>
  }

  export type UserOccurrencesUpdateWithoutOccurrenceInput = {
    date_violence?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserIPUpdateOneRequiredWithoutUserOccurrencesNestedInput
  }

  export type UserOccurrencesUncheckedUpdateWithoutOccurrenceInput = {
    id_user?: BigIntFieldUpdateOperationsInput | bigint | number
    date_violence?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OccurrenceCreateWithoutUserInput = {
    id_occurrence?: bigint | number
    datetime_submission: Date | string
    date_violence?: Date | string | null
    time_violence?: Date | string | null
    agegroup?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    violencesoptions?: string | null
    violencetype?: string | null
    StateList?: StateListCreateNestedOneWithoutOccurrenceInput
    UserOccurrences?: UserOccurrencesCreateNestedOneWithoutOccurrenceInput
  }

  export type OccurrenceUncheckedCreateWithoutUserInput = {
    id_occurrence?: bigint | number
    datetime_submission: Date | string
    State_violence?: string | null
    date_violence?: Date | string | null
    time_violence?: Date | string | null
    agegroup?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    violencesoptions?: string | null
    violencetype?: string | null
    UserOccurrences?: UserOccurrencesUncheckedCreateNestedOneWithoutOccurrenceInput
  }

  export type OccurrenceCreateOrConnectWithoutUserInput = {
    where: OccurrenceWhereUniqueInput
    create: XOR<OccurrenceCreateWithoutUserInput, OccurrenceUncheckedCreateWithoutUserInput>
  }

  export type OccurrenceCreateManyUserInputEnvelope = {
    data: OccurrenceCreateManyUserInput | OccurrenceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserOccurrencesCreateWithoutUserInput = {
    date_violence: Date | string
    Occurrence: OccurrenceCreateNestedOneWithoutUserOccurrencesInput
  }

  export type UserOccurrencesUncheckedCreateWithoutUserInput = {
    id_occurrence: bigint | number
    date_violence: Date | string
  }

  export type UserOccurrencesCreateOrConnectWithoutUserInput = {
    where: UserOccurrencesWhereUniqueInput
    create: XOR<UserOccurrencesCreateWithoutUserInput, UserOccurrencesUncheckedCreateWithoutUserInput>
  }

  export type UserOccurrencesCreateManyUserInputEnvelope = {
    data: UserOccurrencesCreateManyUserInput | UserOccurrencesCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type OccurrenceUpsertWithWhereUniqueWithoutUserInput = {
    where: OccurrenceWhereUniqueInput
    update: XOR<OccurrenceUpdateWithoutUserInput, OccurrenceUncheckedUpdateWithoutUserInput>
    create: XOR<OccurrenceCreateWithoutUserInput, OccurrenceUncheckedCreateWithoutUserInput>
  }

  export type OccurrenceUpdateWithWhereUniqueWithoutUserInput = {
    where: OccurrenceWhereUniqueInput
    data: XOR<OccurrenceUpdateWithoutUserInput, OccurrenceUncheckedUpdateWithoutUserInput>
  }

  export type OccurrenceUpdateManyWithWhereWithoutUserInput = {
    where: OccurrenceScalarWhereInput
    data: XOR<OccurrenceUpdateManyMutationInput, OccurrenceUncheckedUpdateManyWithoutUserInput>
  }

  export type OccurrenceScalarWhereInput = {
    AND?: OccurrenceScalarWhereInput | OccurrenceScalarWhereInput[]
    OR?: OccurrenceScalarWhereInput[]
    NOT?: OccurrenceScalarWhereInput | OccurrenceScalarWhereInput[]
    id_occurrence?: BigIntFilter<"Occurrence"> | bigint | number
    id_user?: BigIntFilter<"Occurrence"> | bigint | number
    datetime_submission?: DateTimeFilter<"Occurrence"> | Date | string
    State_violence?: StringNullableFilter<"Occurrence"> | string | null
    date_violence?: DateTimeNullableFilter<"Occurrence"> | Date | string | null
    time_violence?: DateTimeNullableFilter<"Occurrence"> | Date | string | null
    agegroup?: StringNullableFilter<"Occurrence"> | string | null
    latitude?: DecimalNullableFilter<"Occurrence"> | Decimal | DecimalJsLike | number | string | null
    longitude?: DecimalNullableFilter<"Occurrence"> | Decimal | DecimalJsLike | number | string | null
    violencesoptions?: StringNullableFilter<"Occurrence"> | string | null
    violencetype?: StringNullableFilter<"Occurrence"> | string | null
  }

  export type UserOccurrencesUpsertWithWhereUniqueWithoutUserInput = {
    where: UserOccurrencesWhereUniqueInput
    update: XOR<UserOccurrencesUpdateWithoutUserInput, UserOccurrencesUncheckedUpdateWithoutUserInput>
    create: XOR<UserOccurrencesCreateWithoutUserInput, UserOccurrencesUncheckedCreateWithoutUserInput>
  }

  export type UserOccurrencesUpdateWithWhereUniqueWithoutUserInput = {
    where: UserOccurrencesWhereUniqueInput
    data: XOR<UserOccurrencesUpdateWithoutUserInput, UserOccurrencesUncheckedUpdateWithoutUserInput>
  }

  export type UserOccurrencesUpdateManyWithWhereWithoutUserInput = {
    where: UserOccurrencesScalarWhereInput
    data: XOR<UserOccurrencesUpdateManyMutationInput, UserOccurrencesUncheckedUpdateManyWithoutUserInput>
  }

  export type UserOccurrencesScalarWhereInput = {
    AND?: UserOccurrencesScalarWhereInput | UserOccurrencesScalarWhereInput[]
    OR?: UserOccurrencesScalarWhereInput[]
    NOT?: UserOccurrencesScalarWhereInput | UserOccurrencesScalarWhereInput[]
    id_occurrence?: BigIntFilter<"UserOccurrences"> | bigint | number
    id_user?: BigIntFilter<"UserOccurrences"> | bigint | number
    date_violence?: DateTimeFilter<"UserOccurrences"> | Date | string
  }

  export type OccurrenceCreateWithoutUserOccurrencesInput = {
    id_occurrence?: bigint | number
    datetime_submission: Date | string
    date_violence?: Date | string | null
    time_violence?: Date | string | null
    agegroup?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    violencesoptions?: string | null
    violencetype?: string | null
    User: UserIPCreateNestedOneWithoutOccurrenceInput
    StateList?: StateListCreateNestedOneWithoutOccurrenceInput
  }

  export type OccurrenceUncheckedCreateWithoutUserOccurrencesInput = {
    id_occurrence?: bigint | number
    id_user: bigint | number
    datetime_submission: Date | string
    State_violence?: string | null
    date_violence?: Date | string | null
    time_violence?: Date | string | null
    agegroup?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    violencesoptions?: string | null
    violencetype?: string | null
  }

  export type OccurrenceCreateOrConnectWithoutUserOccurrencesInput = {
    where: OccurrenceWhereUniqueInput
    create: XOR<OccurrenceCreateWithoutUserOccurrencesInput, OccurrenceUncheckedCreateWithoutUserOccurrencesInput>
  }

  export type UserIPCreateWithoutUserOccurrencesInput = {
    id?: bigint | number
    ip: string
    data?: Date | string
    Occurrence?: OccurrenceCreateNestedManyWithoutUserInput
  }

  export type UserIPUncheckedCreateWithoutUserOccurrencesInput = {
    id?: bigint | number
    ip: string
    data?: Date | string
    Occurrence?: OccurrenceUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserIPCreateOrConnectWithoutUserOccurrencesInput = {
    where: UserIPWhereUniqueInput
    create: XOR<UserIPCreateWithoutUserOccurrencesInput, UserIPUncheckedCreateWithoutUserOccurrencesInput>
  }

  export type OccurrenceUpsertWithoutUserOccurrencesInput = {
    update: XOR<OccurrenceUpdateWithoutUserOccurrencesInput, OccurrenceUncheckedUpdateWithoutUserOccurrencesInput>
    create: XOR<OccurrenceCreateWithoutUserOccurrencesInput, OccurrenceUncheckedCreateWithoutUserOccurrencesInput>
    where?: OccurrenceWhereInput
  }

  export type OccurrenceUpdateToOneWithWhereWithoutUserOccurrencesInput = {
    where?: OccurrenceWhereInput
    data: XOR<OccurrenceUpdateWithoutUserOccurrencesInput, OccurrenceUncheckedUpdateWithoutUserOccurrencesInput>
  }

  export type OccurrenceUpdateWithoutUserOccurrencesInput = {
    id_occurrence?: BigIntFieldUpdateOperationsInput | bigint | number
    datetime_submission?: DateTimeFieldUpdateOperationsInput | Date | string
    date_violence?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time_violence?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agegroup?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    violencesoptions?: NullableStringFieldUpdateOperationsInput | string | null
    violencetype?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserIPUpdateOneRequiredWithoutOccurrenceNestedInput
    StateList?: StateListUpdateOneWithoutOccurrenceNestedInput
  }

  export type OccurrenceUncheckedUpdateWithoutUserOccurrencesInput = {
    id_occurrence?: BigIntFieldUpdateOperationsInput | bigint | number
    id_user?: BigIntFieldUpdateOperationsInput | bigint | number
    datetime_submission?: DateTimeFieldUpdateOperationsInput | Date | string
    State_violence?: NullableStringFieldUpdateOperationsInput | string | null
    date_violence?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time_violence?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agegroup?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    violencesoptions?: NullableStringFieldUpdateOperationsInput | string | null
    violencetype?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserIPUpsertWithoutUserOccurrencesInput = {
    update: XOR<UserIPUpdateWithoutUserOccurrencesInput, UserIPUncheckedUpdateWithoutUserOccurrencesInput>
    create: XOR<UserIPCreateWithoutUserOccurrencesInput, UserIPUncheckedCreateWithoutUserOccurrencesInput>
    where?: UserIPWhereInput
  }

  export type UserIPUpdateToOneWithWhereWithoutUserOccurrencesInput = {
    where?: UserIPWhereInput
    data: XOR<UserIPUpdateWithoutUserOccurrencesInput, UserIPUncheckedUpdateWithoutUserOccurrencesInput>
  }

  export type UserIPUpdateWithoutUserOccurrencesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ip?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    Occurrence?: OccurrenceUpdateManyWithoutUserNestedInput
  }

  export type UserIPUncheckedUpdateWithoutUserOccurrencesInput = {
    id?: BigIntFieldUpdateOperationsInput | bigint | number
    ip?: StringFieldUpdateOperationsInput | string
    data?: DateTimeFieldUpdateOperationsInput | Date | string
    Occurrence?: OccurrenceUncheckedUpdateManyWithoutUserNestedInput
  }

  export type OccurrenceCreateWithoutStateListInput = {
    id_occurrence?: bigint | number
    datetime_submission: Date | string
    date_violence?: Date | string | null
    time_violence?: Date | string | null
    agegroup?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    violencesoptions?: string | null
    violencetype?: string | null
    User: UserIPCreateNestedOneWithoutOccurrenceInput
    UserOccurrences?: UserOccurrencesCreateNestedOneWithoutOccurrenceInput
  }

  export type OccurrenceUncheckedCreateWithoutStateListInput = {
    id_occurrence?: bigint | number
    id_user: bigint | number
    datetime_submission: Date | string
    date_violence?: Date | string | null
    time_violence?: Date | string | null
    agegroup?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    violencesoptions?: string | null
    violencetype?: string | null
    UserOccurrences?: UserOccurrencesUncheckedCreateNestedOneWithoutOccurrenceInput
  }

  export type OccurrenceCreateOrConnectWithoutStateListInput = {
    where: OccurrenceWhereUniqueInput
    create: XOR<OccurrenceCreateWithoutStateListInput, OccurrenceUncheckedCreateWithoutStateListInput>
  }

  export type OccurrenceCreateManyStateListInputEnvelope = {
    data: OccurrenceCreateManyStateListInput | OccurrenceCreateManyStateListInput[]
    skipDuplicates?: boolean
  }

  export type OccurrenceUpsertWithWhereUniqueWithoutStateListInput = {
    where: OccurrenceWhereUniqueInput
    update: XOR<OccurrenceUpdateWithoutStateListInput, OccurrenceUncheckedUpdateWithoutStateListInput>
    create: XOR<OccurrenceCreateWithoutStateListInput, OccurrenceUncheckedCreateWithoutStateListInput>
  }

  export type OccurrenceUpdateWithWhereUniqueWithoutStateListInput = {
    where: OccurrenceWhereUniqueInput
    data: XOR<OccurrenceUpdateWithoutStateListInput, OccurrenceUncheckedUpdateWithoutStateListInput>
  }

  export type OccurrenceUpdateManyWithWhereWithoutStateListInput = {
    where: OccurrenceScalarWhereInput
    data: XOR<OccurrenceUpdateManyMutationInput, OccurrenceUncheckedUpdateManyWithoutStateListInput>
  }

  export type OccurrenceCreateManyUserInput = {
    id_occurrence?: bigint | number
    datetime_submission: Date | string
    State_violence?: string | null
    date_violence?: Date | string | null
    time_violence?: Date | string | null
    agegroup?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    violencesoptions?: string | null
    violencetype?: string | null
  }

  export type UserOccurrencesCreateManyUserInput = {
    id_occurrence: bigint | number
    date_violence: Date | string
  }

  export type OccurrenceUpdateWithoutUserInput = {
    id_occurrence?: BigIntFieldUpdateOperationsInput | bigint | number
    datetime_submission?: DateTimeFieldUpdateOperationsInput | Date | string
    date_violence?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time_violence?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agegroup?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    violencesoptions?: NullableStringFieldUpdateOperationsInput | string | null
    violencetype?: NullableStringFieldUpdateOperationsInput | string | null
    StateList?: StateListUpdateOneWithoutOccurrenceNestedInput
    UserOccurrences?: UserOccurrencesUpdateOneWithoutOccurrenceNestedInput
  }

  export type OccurrenceUncheckedUpdateWithoutUserInput = {
    id_occurrence?: BigIntFieldUpdateOperationsInput | bigint | number
    datetime_submission?: DateTimeFieldUpdateOperationsInput | Date | string
    State_violence?: NullableStringFieldUpdateOperationsInput | string | null
    date_violence?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time_violence?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agegroup?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    violencesoptions?: NullableStringFieldUpdateOperationsInput | string | null
    violencetype?: NullableStringFieldUpdateOperationsInput | string | null
    UserOccurrences?: UserOccurrencesUncheckedUpdateOneWithoutOccurrenceNestedInput
  }

  export type OccurrenceUncheckedUpdateManyWithoutUserInput = {
    id_occurrence?: BigIntFieldUpdateOperationsInput | bigint | number
    datetime_submission?: DateTimeFieldUpdateOperationsInput | Date | string
    State_violence?: NullableStringFieldUpdateOperationsInput | string | null
    date_violence?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time_violence?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agegroup?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    violencesoptions?: NullableStringFieldUpdateOperationsInput | string | null
    violencetype?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserOccurrencesUpdateWithoutUserInput = {
    date_violence?: DateTimeFieldUpdateOperationsInput | Date | string
    Occurrence?: OccurrenceUpdateOneRequiredWithoutUserOccurrencesNestedInput
  }

  export type UserOccurrencesUncheckedUpdateWithoutUserInput = {
    id_occurrence?: BigIntFieldUpdateOperationsInput | bigint | number
    date_violence?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserOccurrencesUncheckedUpdateManyWithoutUserInput = {
    id_occurrence?: BigIntFieldUpdateOperationsInput | bigint | number
    date_violence?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type OccurrenceCreateManyStateListInput = {
    id_occurrence?: bigint | number
    id_user: bigint | number
    datetime_submission: Date | string
    date_violence?: Date | string | null
    time_violence?: Date | string | null
    agegroup?: string | null
    latitude?: Decimal | DecimalJsLike | number | string | null
    longitude?: Decimal | DecimalJsLike | number | string | null
    violencesoptions?: string | null
    violencetype?: string | null
  }

  export type OccurrenceUpdateWithoutStateListInput = {
    id_occurrence?: BigIntFieldUpdateOperationsInput | bigint | number
    datetime_submission?: DateTimeFieldUpdateOperationsInput | Date | string
    date_violence?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time_violence?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agegroup?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    violencesoptions?: NullableStringFieldUpdateOperationsInput | string | null
    violencetype?: NullableStringFieldUpdateOperationsInput | string | null
    User?: UserIPUpdateOneRequiredWithoutOccurrenceNestedInput
    UserOccurrences?: UserOccurrencesUpdateOneWithoutOccurrenceNestedInput
  }

  export type OccurrenceUncheckedUpdateWithoutStateListInput = {
    id_occurrence?: BigIntFieldUpdateOperationsInput | bigint | number
    id_user?: BigIntFieldUpdateOperationsInput | bigint | number
    datetime_submission?: DateTimeFieldUpdateOperationsInput | Date | string
    date_violence?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time_violence?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agegroup?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    violencesoptions?: NullableStringFieldUpdateOperationsInput | string | null
    violencetype?: NullableStringFieldUpdateOperationsInput | string | null
    UserOccurrences?: UserOccurrencesUncheckedUpdateOneWithoutOccurrenceNestedInput
  }

  export type OccurrenceUncheckedUpdateManyWithoutStateListInput = {
    id_occurrence?: BigIntFieldUpdateOperationsInput | bigint | number
    id_user?: BigIntFieldUpdateOperationsInput | bigint | number
    datetime_submission?: DateTimeFieldUpdateOperationsInput | Date | string
    date_violence?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    time_violence?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    agegroup?: NullableStringFieldUpdateOperationsInput | string | null
    latitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    longitude?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    violencesoptions?: NullableStringFieldUpdateOperationsInput | string | null
    violencetype?: NullableStringFieldUpdateOperationsInput | string | null
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserIPCountOutputTypeDefaultArgs instead
     */
    export type UserIPCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserIPCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StateListCountOutputTypeDefaultArgs instead
     */
    export type StateListCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StateListCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use OccurrenceDefaultArgs instead
     */
    export type OccurrenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = OccurrenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TypesOfViolenceDefaultArgs instead
     */
    export type TypesOfViolenceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TypesOfViolenceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserIPDefaultArgs instead
     */
    export type UserIPArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserIPDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserOccurrencesDefaultArgs instead
     */
    export type UserOccurrencesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserOccurrencesDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ViolenceSituationsDefaultArgs instead
     */
    export type ViolenceSituationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ViolenceSituationsDefaultArgs<ExtArgs>
    /**
     * @deprecated Use StateListDefaultArgs instead
     */
    export type StateListArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = StateListDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AccessDefaultArgs instead
     */
    export type AccessArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AccessDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}